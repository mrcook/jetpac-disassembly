; SkoolKit disassembly for JETPAC (cartridge)
; (https://github.com/mrcook/jetpac-disassembly)
;
; Copyright (c) 2020 Michael R. Cook (this disassembly)
; Copyright (c) 1983 Ultimate Play the Game (JETPAC)
; JETPAC was designed and developed by Tim Stamper and Chris Stamper
@start=$6000

; Frame counter.
;
; These lower two bytes of frame counter are incremented every 20 ms.
@equ=SYSVAR_FRAMES=$5c78

@org
; Stack: 37 bytes of memory allocated for use as the system stack.
@label=stack_memory
s$5ccb defs $25

; High score for current game session.
;
; A 3-byte decimal representation of the score. Maximum value is 999999.
@label=hi_score
b$5cf0 defs $03

; Game options.
;
; #TABLE(default,centre,:w)
; { =h Bits(n) | =h Option }
; { 0 | Players (reset=1, set=2) }
; { 1 | Input Type (reset=Keyboard, set=Joystick) }
; TABLE#
@label=game_options
b$5cf3 defb $00

; Player one score.
;
; A 3-byte decimal representation of the score. Maximum value is 999999.
@label=p1_score
b$5cf4 defs $03

; Player two score.
;
; A 3-byte decimal representation of the score. Maximum value is 999999.
@label=p2_score
b$5cf7 defs $03

; Padding to make block from hi_score to here 16 bytes in length.
s$5cfa defs $06

; Jetman direction.
;
; Indicates the direction that Jetman is travelling/facing.
; #TABLE(default,centre,:w)
; { =h Byte | =h Bits | =h Direction }
; { 82 | 10000010 | WALK RIGHT }
; { C2 | 11000010 | WALK LEFT }
; { 01 | 00000001 | FLY UP RIGHT (default) }
; { 41 | 01000001 | FLY UP LEFT }
; { 81 | 10000001 | FLY DOWN RIGHT }
; { C1 | 11000001 | FLY DOWN LEFT }
; TABLE#
@label=jetman_direction
b$5d00 defb $00

; Jetman X position.
;
; Default start position is $80.
@label=jetman_pos_x
b$5d01 defb $00

; Jetman Y position.
;
; Default start position is $B7.
@label=jetman_pos_y
b$5d02 defb $00

; Jetman sprite colour attribute.
;
; Initialised to $47 on new player.
@label=jetman_colour
b$5d03 defb $00

; Jetman moving direction.
;
; Indicates the direction in which Jetman is moving.
; #TABLE(default,centre,:w)
; { =h Bits(n) | =h Direction }
; { 6 | 0=right, 1=left }
; { 7 | 0=up/standing still, 1=down }
; { 1 | ? }
; { 0 | 0=horizontal, 1=vertical }
; TABLE#
@label=jetman_moving
b$5d04 defb $00

; Jetman Speed: Horizontal.
;
; Max Walking: $20. Max Flying: $40.
@label=jetman_speed_x
b$5d05 defb $00

; Jetman Speed: Vertical.
;
; Max: $3F.
@label=jetman_speed_y
b$5d06 defb $00

; Jetman sprite height, which is always $24, as set by the defaults.
@label=jetman_height
b$5d07 defb $00

; Laser beams
;
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Variable }
; { 0 | Unused=$00, Used=$10 }
; { 1 | Y Position }
; { 2 | X position pulse #1 }
; { 3 | X position pulse #2 }
; { 4 | X position pulse #3 }
; { 5 | X position pulse #4 }
; { 6 | Beam length }
; { 7 | Colour attribute }
; TABLE#
@label=laser_beam_params
b$5d08 defb $00,$00,$00,$00,$00,$00,$00,$00 ; laser beam #1
 $5d10 defb $00,$00,$00,$00,$00,$00,$00,$00 ; laser beam #2
 $5d18 defb $00,$00,$00,$00,$00,$00,$00,$00 ; laser beam #3
 $5d20 defb $00,$00,$00,$00,$00,$00,$00,$00 ; laser beam #4

; Sound type parameters for explosions.
;
; Byte 1=Frequency, byte 2=Duration.
@label=explosion_sfx_params
b$5d28 defb $00      ; Frequency is $0C or $0D
 $5d29 defb $00      ; Length is always set to $04

; Explosion params padding, making 8 bytes total. Unused.
b$5d2a defs $06

; Rocket object attributes.
;
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Variable }
; { 0 | Movement: $09=on pad, $0A=up, $0B=down }
; { 1 | X Position (pixels) }
; { 2 | Y Position (pixels) (base module) }
; { 3 | Colour Attribute }
; { 4 | Modules on Pad: $01 (new level default) to $03 }
; { 5 | Fuel Pods collected: 0-6 }
; { 6 | Unused }
; { 7 | Always $1C }
; TABLE#
@label=rocket_state
b$5d30 defb $00,$00,$00,$00,$00,$00,$00,$00

; Rocket module state (fuel/part).
;
; NOTE: Used for top module at level start, then only fuel pods.
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Variable }
; { 0 | Type: $00=Unused, $04=Ship/Fuel Pod }
; { 1 | X Position (pixels) }
; { 2 | Y Position (pixels) }
; { 3 | Colour Attribute }
; { 4 | State: 1=new, 3=collected, 5=free-fall, 7=dropped }
; { 5 | Unused }
; { 6 | Sprite jump table offset }
; { 7 | Sprite Height }
; TABLE#
@label=rocket_module_state
b$5d38 defb $00,$00,$00,$00,$00,$00,$00,$00

; Current Collectible object.
;
; Used for the middle ship module at level start, then only collectibles. The
; "state" field is not used for collectibles (remains $00).
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Variable }
; { 0 | Type: $00=Unused, $04=Rocket, $0E=Collectible }
; { 1 | X Position (pixels) }
; { 2 | Y Position (pixels) }
; { 3 | Colour Attribute }
; { 4 | State: 1=new, 3=collected, 5=free-fall, 7=dropped }
; { 5 | Unused }
; { 6 | Sprite jump table offset }
; { 7 | Sprite Height }
; TABLE#
@label=item_state
b$5d40 defb $00,$00,$00,$00,$00,$00,$00,$00

; Thruster/Explosion animation sprite state.
;
; Holds the sprite state for the current animation frame being displayed for
; Jetman's jetpac thruster "smoke". Note: each animation loop uses a (random)
; two colour pair from the 4 possible colours.
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Variable }
; { 0 | Animating: 00=no, 03=anim done, 08=animating }
; { 1 | Last Jetman X location }
; { 2 | Last Jetman Y location }
; { 3 | Colour: Red, Magenta, Yellow, White }
; { 4 | Frame: 0-7 }
; { 5 | Unused }
; { 6 | Unknown (set to $03 on first use) }
; { 7 | Unused }
; TABLE#
@label=jetman_thruster_anim_state
b$5d48 defb $00,$00,$00,$00,$00,$00,$00,$00

; Alien state objects.
;
; There are a maximum of 6 aliens on the screen at one time, and those states
; are stored here in this data block. See Jetman object for more details.
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Variable }
; { 00 | Direction }
; { 01 | X location (pixels) }
; { 02 | Y location (pixels) }
; { 03 | Colour attribute }
; { 04 | Moving direction }
; { 05 | X Speed (default: $04) }
; { 06 | Y Speed }
; { 07 | Sprite Height }
; TABLE#
@label=alien_states
b$5d50 defb $00,$00,$00,$00,$00,$00,$00,$00 ; slot #1
 $5d58 defb $00,$00,$00,$00,$00,$00,$00,$00 ; slot #2
 $5d60 defb $00,$00,$00,$00,$00,$00,$00,$00 ; slot #3
 $5d68 defb $00,$00,$00,$00,$00,$00,$00,$00 ; slot #4
 $5d70 defb $00,$00,$00,$00,$00,$00,$00,$00 ; slot #5
 $5d78 defb $00,$00,$00,$00,$00,$00,$00,$00 ; slot #6

; Jetman exploding animation object.
;
; Holds the sprite state for the current animation frame being displayed for
; the explosion sprite when Jetman is killed. Note: each animation loop uses a
; (random) two colour pair from the 4 possible colours.
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Variable }
; { 0 | Animating: 00=no, 08=yes }
; { 1 | Jetman X location (pixels) }
; { 2 | Jetman Y location (pixels) }
; { 3 | Colour: Red, Magenta, Yellow, White }
; { 4 | Frame: 0-7 }
; { 5 | State (set=animating) }
; { 6 | Jetman direction }
; { 7 | Unused }
; TABLE#
@label=jetman_exploding_anim_state
b$5d80 defb $00,$00,$00,$00,$00,$00,$00,$00

; Jetman object backup for the inactive player.
@label=inactive_jetman_state
b$5d88 defb $00,$00,$00,$00,$00,$00,$00,$00

@defs=$5D90:$08,$00
; Unused padding.
s$5d90 defs $08

; Rocket/collectible object backup for the inactive player.
@label=inactive_rocket_state
b$5d98 defb $00,$00,$00,$00,$00,$00,$00,$00 ; Rocket object
 $5da0 defb $00,$00,$00,$00,$00,$00,$00,$00 ; Rocket module (fuel/part)
 $5da8 defb $00,$00,$00,$00,$00,$00,$00,$00 ; Collectible/Rocket middle

@defs=$5DB0:$06,$00
; Unused padding.
s$5db0 defs $08

@defs=$5DB8:$06,$00
; Unused padding.
s$5db8 defs $08

; Temporary actor state.
;
; Many actor routines use this to hold state temporarily during updates.
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Variable }
; { 0 | X location }
; { 1 | Y location }
; { 2 | Movement direction }
; { 3 | Height (pixels) }
; { 4 | Width (tiles) }
; { 5 | Current sprite height value (?) }
; { 6 | Sprite GFX data height value (?) }
; { 7 | Unknown flying movement/direction (used only for Jetman?) }
; TABLE#
@label=actor
b$5dc0 defb $00,$00,$00,$00,$00,$00,$00,$00

; Value only changes while Jetman is moving up/down - has no obvious pattern.
@label=jetman_fly_counter
b$5dc8 defb $00

; Alien direction update flag for: Squidgy, UFO, Sphere, Crossed Ship.
;
; Each alien update routine first resets the value, then after the first check,
; increments the value, which triggers the draw alien routine.
@label=alien_new_dir_flag
b$5dc9 defb $00

; Jetman speed modifier.
;
; Initialised to $04 by initialise game routine, otherwise value is $00 during
; game play.
@label=jetman_speed_modifier
b$5dca defb $00

; Current alien ID being updated?
;
; Values are $00 (no alien update?) up to the max number of aliens: $01 to $06.
; Used by all alien update routines and in a few other places.
@label=current_alien_number
b$5dcb defb $00

; Game timer.
;
; 16-bit counter starting at 0x0000 and counting +1 (each time a sprite is
; moved or redrawn?), although sometimes it will increment +2. This continues
; until the whole game is over - for both 1 and 2 player games. Counter loops
; around after reaching 0xFFFF.
@label=game_timer
w$5dcc defw $0000

; Random Number.
;
; Value is calculated using the 16-bit game timer LSB value, which is used to
; fetch a byte from the ROM (between addresses $00 and $FF), then by adding the
; current #REGr.
@label=random_number
b$5dce defb $00

; Temporary actor coordinates.
;
; Coordinates (Y,X) used when colouring a sprite. Set by the Actor, along with
; being inc/decremented during the Rocket launch/land phase.
@label=actor_coords
b$5dcf defb $00      ; Y location (pixels)
 $5dd0 defb $00      ; X location (pixels)

; Current active player.
;
; $00=player #1, $FF=player #2.
@label=current_player_number
b$5dd1 defb $00

; Jetman Rocket module attached success.
;
; Set to $01 at the start of each new life/level. When one of the two modules
; becomes attached to the Rocket (top or middle, but not fuel) then this is
; changed to $00.
@label=jetman_rocket_mod_connected
b$5dd2 defb $00

; Rocket modules attached.
;
; Set to $04 at the start of each new level. When one of the two modules
; becomes attached to the Rocket (top or middle, but not fuel) then this is
; changed to $02.
@label=rocket_mod_attached
b$5dd3 defb $00

; Holds a copy of the last SYSVAR_FRAMES counter.
@label=last_frame
b$5dd4 defb $00

; Has a frame ticked over.
;
; $00=no, $01=yes.
@label=frame_ticked
b$5dd5 defb $00

; Current menu item colour attribute.
@label=current_colour_attr
b$5dd6 defb $00

; "Get Ready" delay timer.
;
; At the beginning of each player turn there is a delay to allow the player to
; be ready for play. Values are $80 for a 1 player game, $FF for a two player
; game. The larger delay is useful for swapping players controls.
@label=begin_play_delay_counter
b$5dd7 defb $00

@defs=$5DD8:$06,$00
; Unused padding.
s$5dd8 defs $18

; Game level for current player.
;
; Level #1 starts at $00.
@label=player_level
b$5df0 defb $00

; Current player lives remaining.
@label=player_lives
b$5df1 defb $00

@defs=$5DF2:$08,$00
; Unused padding for player level/lives object (8 bytes total).
s$5df2 defs $06

; Game level for inactive player.
;
; Level #1 starts at $00.
@label=inactive_player_level
b$5df8 defb $00

; Inactive player lives remaining.
@label=inactive_player_lives
b$5df9 defb $00

@defs=$5DFA:$08,$00
; Unused padding for inactive player level/lives object (8 bytes total).
s$5dfa defs $06

; Buffers for Alien sprites.
;
; 4 buffers representing left/right facing aliens, with 2 animation frames
; each.
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Meaning }
; { $00     | Header byte - always NULL? }
; { $01     | Width value - always $03 }
; { $02     | Height value }
; { $03-$33 | Pixel data }
; TABLE#
@label=buffers_aliens_R1
b$5e00 defs $33      ; right facing, anim frame 1
@label=buffers_aliens_R2
 $5e33 defs $33      ; right facing, anim frame 2
@label=buffers_aliens_L1
 $5e66 defs $33      ; left facing, anim frame 1
@label=buffers_aliens_L2
 $5e99 defs $33      ; left facing, anim frame 2

; Buffers for Collectible/Rocket sprites.
;
; Buffer to hold 4 item sprites.
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Meaning }
; { $00     | Header byte }
; { $01     | Width value - always $03? }
; { $02     | Height value }
; { $03-$33 | Pixel data }
; TABLE#
@label=buffers_item_1
b$5ecc defs $33      ; sprite 1
@label=buffers_item_2
 $5eff defs $33      ; sprite 2
@label=buffers_item_3
 $5f32 defs $33      ; sprite 3
@label=buffers_item_4
 $5f65 defs $33      ; sprite 4

@defs=$5F98:$68,$00
; Unused padding.
s$5f98 defs $68

; #REGpc starts here, after game load.
@label=EntryPoint
c$6000 jp $61bf      ;

; Platform GFX location and size.
;
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Variable }
; { 1 | Colour Attribute }
; { 2 | X location (pixels) }
; { 3 | Y location (pixels) }
; { 4 | Width }
; TABLE#
@label=gfx_params_platforms
b$6003 defb $04,$80,$60,$1b ; Middle
 $6007 defb $06,$78,$b8,$88 ; Bottom
 $600b defb $04,$30,$48,$23 ; Left
 $600f defb $04,$d0,$30,$23 ; Right

; Default player object state.
@label=default_player_state
b$6013 defb $01,$80,$b7,$47,$00,$00,$00,$24

; Default Rocket and module objects state.
@label=default_rocket_state
b$601b defb $09,$a8,$b7,$02,$01,$00,$00,$1c ; Rocket state
 $6023 defb $04,$30,$47,$47,$00,$00,$10,$18 ; Top module state
 $602b defb $04,$80,$5f,$47,$01,$00,$08,$18 ; Middle module state

; Default Rocket module state is a Fuel Pod.
@label=default_rocket_module_state
b$6033 defb $04,$00,$20,$43,$01,$00,$18,$18

; Default collectible item state.
@label=default_item_state
b$603b defb $0e,$00,$20,$00,$00,$00,$00,$18

; Main menu copyright message.
@label=menu_copyright
b$6043 defb $47                              ; Text colour attribute
 $6044 defb $5b                              ; Font code for © symbol
 $6045 defm "1983 A.C.G. ALL RIGHTS RESERVE"
 $6063 defb $c4                              ; ASCII "D" & $80 (EOL)

; Reset the screen to its default state.
;
; Used by the routines at #R$6094, #R$60b7 and #R$61c9.
@label=ResetScreen
c$6064 xor a         ;
 $6065 out ($fe),a   ; Set screen border to black
 $6067 call $7180    ; Clear the screen
 $606a call $718e    ; Reset the screen colours
 $606d call $715a    ; Display score labels
; Display score labels text at the top of the screen.
 $6070 ld hl,$5820   ; #REGhl=attribute file location
 $6073 ld bc,$2046   ; #REGb=tile count, and #REGc=yellow colour
*$6076 ld (hl),c     ; {Now set the tile colours
 $6077 inc l         ;
 $6078 djnz $6076    ; }
 $607a call $70e5    ; Update display with player 1 score
 $607d call $70ed    ; Update display with player 2 score
 $6080 jp $70f5      ; Update display with high score

; Initialises a new level.
;
; A new Rocket is generated every 4 levels, otherwise it's a normal fuel
; collecting level. Used by the routines at #R$62fe and #R$6690.
@label=LevelNew
c$6083 ld a,($5df0)  ; {Check if player level is a MOD of 4?
 $6086 and $03       ; }
 $6088 jr nz,$6094   ; If not, initialise the level normally
; Initialisation for a new rocket level.
 $608a call $60a7    ; Reset all rocket modules with defaults
 $608d ld hl,$5df1   ; {Jetman has boarded the rocket; increment lives count.
 $6090 inc (hl)      ; Used for display purposes only}
 $6091 call $6174    ; Initialise the player for the next level

; Initialise the level.
;
; Used by the routines at #R$6083 and #R$60b7.
@label=LevelInit
c$6094 call $68f2    ; Initialise alien buffers
 $6097 call $6064    ; Initialise the screen
 $609a call $7638    ; Draw the platforms
 $609d call $706d    ; Display all player lives
 $60a0 ld a,($5c78)  ; {Set last_frame to current SYSVAR_FRAMES
 $60a3 ld ($5dd4),a  ; }
 $60a6 ret           ;

; Reset all rocket module states to their defaults.
;
; Set object data to their defaults and copy to buffers. Used by the routines
; at #R$6083 and #R$62da.
@label=RocketReset
c$60a7 ld hl,$601b   ; #REGhl=default rocket data
 $60aa ld de,$5d30   ; #REGde=start of rocket structs
 $60ad ld bc,$0018   ; 24 bytes of rocket data to copy
 $60b0 ldir          ;
 $60b2 ld a,$08      ;
 $60b4 jp $6ec2      ; Copy sprite data to the buffers.

; End of turn for the current player.
;
; Resets level states/buffers, and checks if it's game over for a player. Used
; by the routine at #R$687a.
@label=PlayerTurnEnds
c$60b7 ld hl,$5d48   ; #REGhl=Jetman thruster animation object
 $60ba ld b,$0a      ; {Reset all object states to be inactive
 $60bc call $6629    ; }
@ssub=ld hl,$5d38+$04 ; #REGhl=Rocket module "state" field
 $60bf ld hl,$5d3c   ;
 $60c2 res 1,(hl)    ; Set to unused state
@ssub=ld hl,$5d40+$04 ; #REGhl=Collectible item "state" field
 $60c4 ld hl,$5d44   ;
 $60c7 res 1,(hl)    ; Set to unused state
; Check if current and inactive player has lives, if not it is game over.
 $60c9 ld a,($5cf3)  ; Game Options
 $60cc and $01       ;
 $60ce jr nz,$60dd   ; Jump if two player
*$60d0 ld a,($5df1)  ; Current player lives
 $60d3 and a         ;
 $60d4 jp z,$612f    ; Game over if no lives remaining
 $60d7 call $6094    ; Initialise a new level
 $60da jp $6174      ; Initialise next player
*$60dd ld a,($5df9)  ; Inactive player lives
 $60e0 and a         ;
 $60e1 jr z,$60d0    ; Game over if no lives remaining
 $60e3 ld a,($5df1)  ; Current player lives
 $60e6 and a         ;
 $60e7 call z,$6127  ; Game over if no lives remaining
 $60ea call $6144    ; Switch players
 $60ed ld a,($5dd1)  ; {Change current player (flip bits between $00 and $FF)
 $60f0 cpl           ;
 $60f1 ld ($5dd1),a  ; }
; Switch rocket objects data for this new player
@ssub=ld a,($5d30+$04) ; Rocket module "state" field
 $60f4 ld a,($5d34)  ;
 $60f7 rlca          ; {Calculate the offset
 $60f8 rlca          ;
 $60f9 rlca          ;
 $60fa and $38       ; }
 $60fc call $6ec2    ; Copy rocket sprite to buffer
 $60ff call $6094    ; Initialise level
 $6102 jp $6174      ; Initialise player
; Display the GAME OVER message for a player.
*$6105 ld a,$b1      ; ASCII character for the number "1" + EOL bit
@ssub=ld ($6161+$12),a ; Append the number to game over text
*$6107 ld ($6173),a  ;
 $610a call $6064    ; Initialise level screen
 $610d ld de,$6161   ; Game Over message
@keep
 $6110 ld hl,$7038   ; Y,X coords in the display file
 $6113 call $7134    ; Draw text to the screen
; After displaying the text, pause for a while.
 $6116 ld b,$04      ;
 $6118 ld hl,$0000   ;
*$611b dec hl        ;
 $611c ld a,h        ;
 $611d or l          ;
 $611e jr nz,$611b   ;
 $6120 djnz $611b    ;
 $6122 ret           ;
; Handle message for player #2.
*$6123 ld a,$b2      ; ASCII character for the number "2" + EOL bit
 $6125 jr $6107      ; Append the number to the text, the display it
; Choose which player to show Game Over message for.
*$6127 ld a,($5dd1)  ; {Jump if current player is #1
 $612a and a         ;
 $612b jr z,$6105    ; }
 $612d jr $6123      ; else, player is #2.
; Game Over: update scores, show game over message, and initialise system.
*$612f call $6361    ; Update the high score
 $6132 ld a,($5dd1)  ; {Jump if current player is #2
 $6135 and a         ;
 $6136 jr nz,$613e   ; }
 $6138 call $6105    ; Display game over for player #1
 $613b jp $61c9      ; Reset the game
*$613e call $6123    ; Display game over for player #2
 $6141 jp $61c9      ; Reset the game

; Swap current/inactive player/rocket states.
;
; Used by the routines at #R$60b7 and #R$62da.
@label=PlayersSwap
c$6144 ld hl,$5df0   ; Current player level/lives
 $6147 ld de,$5df8   ; Inactive player level/lives
 $614a ld b,$02      ;
 $614c call $6157    ; Swap 2 bytes
; Now swap the current/inactive rocket states.
 $614f ld hl,$5d30   ; Current player rocker state
 $6152 ld de,$5d98   ; Inactive player rocker state
 $6155 ld b,$18      ; We will be swapping 24 bytes
; Sub-routine for swapping HL/DE bytes.
*$6157 ld a,(de)     ;
 $6158 ld c,(hl)     ;
 $6159 ld (hl),a     ;
 $615a ld a,c        ;
 $615b ld (de),a     ;
 $615c inc hl        ;
 $615d inc de        ;
 $615e djnz $6157    ;
 $6160 ret           ;

; Text for game over message.
@label=game_over_text
b$6161 defb $47                 ; Colour attribute
 $6162 defm "GAME OVER PLAYER "
 $6173 defb $b1                 ; Player # (ASCII $31/$32) + $80 (EOL)

; Initialise player for new turn.
;
; Player has died, or started a new level, so Jetman object should be updated
; with default values. Used by the routines at #R$6083, #R$60b7 and #R$66b4.
@label=PlayerInit
c$6174 ld hl,$6013   ; Default Jetman values
 $6177 ld de,$5d00   ; Jetman object
 $617a ld bc,$0008   ;
 $617d ldir          ;
; Set default "begin play" delay period.
 $617f ld a,$80      ; 1 player delay
 $6181 ld hl,$5cf3   ; Game options
 $6184 bit 0,(hl)    ;
 $6186 jr z,$618a    ; Jump if one player game
 $6188 add a,$7f     ; else, double delay for 2 player game
*$618a ld ($5dd7),a  ; Update delay: 1 Player=$80, 2 Player=$FF
; Decrement current player lives and update display.
 $618d ld a,($5df1)  ; Current player lives
 $6190 dec a         ;
 $6191 ld ($5df1),a  ;
 $6194 jp $706d      ; Display player lives

; Flash 1UP or 2UP score label for active player.
;
; Used by the routine at #R$737d.
@label=ScoreLabelFlash
c$6197 ld a,($5dd1)  ; Current player number
 $619a and a         ;
 $619b jr nz,$61ba   ; If player #2, flash 2UP text
 $619d ld hl,$0018   ; else #REGhl=1UP column position in attr file

; Set flash state for the 3-attributes of the score label.
;
; Used by the routine at #R$61ba.
;
; Input:HL screen coordinate.
@label=FlashText
c$61a0 call $71d6    ; #REGhl=coord to attribute file address (using #REGhl)
 $61a3 ld b,$03      ; Loop counter for 3 characters
*$61a5 ld a,(hl)     ; {Set FLASH on for each attribute
 $61a6 or $80        ;
 $61a8 ld (hl),a     ;
 $61a9 inc hl        ;
 $61aa djnz $61a5    ; }
 $61ac ret           ;

; Turn off flashing of 1UP or 2UP score label for active player.
;
; Used by the routine at #R$737d.
;
; Input:HL screen coordinate.
@label=ScoreLabelUnflash
c$61ad call $71d6    ; #REGhl=coord to attribute file address (using #REGhl)
 $61b0 ld b,$03      ; Loop counter for 3 characters
*$61b2 ld a,(hl)     ; {Set FLASH=off on for each attribute
 $61b3 and $7f       ;
 $61b5 ld (hl),a     ;
 $61b6 inc hl        ;
 $61b7 djnz $61b2    ; }
 $61b9 ret           ;

; Flash 2UP score label.
;
; Used by the routine at #R$6197.
@label=FlashScoreLabel2UP
c$61ba ld hl,$00d8   ; 2UP column position in attribute file
 $61bd jr $61a0      ;

; Game initialisation for first run.
;
; Reset all scores, sets the SP, initialises the screen, and displays the main
; menu. Used by the routine at #R$6000.
@label=StartGame
c$61bf ld hl,$5cf0   ; {Reset all scores
 $61c2 ld bc,$0a00   ;
*$61c5 ld (hl),c     ;
 $61c6 inc hl        ;
 $61c7 djnz $61c5    ; }

; Reset system and show menu screen.
;
; Used by the routine at #R$60b7.
@label=ResetGame
c$61c9 di            ; Interrupts are disabled for the core engine code
@ssub=ld sp,$5ccb+$25 ; Set the stack pointer
 $61ca ld sp,$5cf0   ;
 $61cd call $6064    ; Reset the screen
 $61d0 ld a,$04      ;
 $61d2 ld ($5dca),a  ; Reset Speed modifier to its default

; Show menu screen and handle menu selection.
@label=MenuScreen
c$61d5 call $6234    ; Draw the menu entries
 $61d8 ld a,($5cf3)  ; {#REGd=Game options
 $61db ld d,a        ; }
; Read the keyboard and perform menu selection.
 $61dc ld a,$f7      ; Row: 1,2,3,4,5
 $61de out ($fd),a   ; Set port for reading keyboard
 $61e0 in a,($fe)    ; ...and read that row of keys
 $61e2 cpl           ; Flip bits so a `1` means a key is pressed.
 $61e3 bit 0,a       ; Key #1 pressed? ("1 PLAYER GAME")
 $61e5 jr z,$61e9    ; No key pressed? Jump
 $61e7 res 0,d       ; else, Player count = 1
*$61e9 bit 1,a       ; Key #2 pressed? ("2 PLAYER GAME")
 $61eb jr z,$61ef    ; No key pressed? Jump
 $61ed set 0,d       ; else, Player count = 2
*$61ef bit 2,a       ; Key #3 pressed? ("KEYBOARD")
 $61f1 jr z,$61f5    ; No key pressed? Jump
 $61f3 res 1,d       ; else, Input type = keyboard
*$61f5 bit 3,a       ; Key #4 pressed? ("JOYSTICK")
 $61f7 jr z,$61fb    ; No key pressed? Jump
 $61f9 set 1,d       ; else, Input type = joystick
*$61fb bit 4,a       ; {Key #5 pressed? ("START GAME")
 $61fd jp nz,$62fe   ; }
 $6200 ld a,d        ; {Update the Game options
 $6201 ld ($5cf3),a  ; }
; Update flashing state of the menu items.
@ssub=ld hl,$6261+$01
 $6204 ld hl,$6262   ; Point #REGhl to main menu colour attributes list.
 $6207 ld a,($5cf3)  ; {#REGc=Game options
 $620a ld c,a        ; }
 $620b bit 0,c       ; {Jump if player count = 2
 $620d jr nz,$621c   ; }
 $620f call $6226    ; Set flashing state for a one player game
*$6212 bit 1,c       ; {Jump if input type = joystick
 $6214 jr nz,$6221   ; }
 $6216 call $6226    ; Set flashing state for keyboard input
*$6219 jp $61d5      ; Loop and process again main menu input
*$621c call $622d    ; Set flashing state for a two player game
 $621f jr $6212      ; Check input type
*$6221 call $622d    ; Set flashing state for joystick input
 $6224 jr $6219      ; Loop and process again menu selection
; Set flashing state for "1 PLAYER GAME" and "KEYBOARD" menu items.
*$6226 set 7,(hl)    ;
 $6228 inc hl        ;
 $6229 res 7,(hl)    ;
 $622b inc hl        ;
 $622c ret           ;
; Set "2 PLAYER GAME" and "JOYSTICK" menu items flashing.
*$622d res 7,(hl)    ;
 $622f inc hl        ;
 $6230 set 7,(hl)    ;
 $6232 inc hl        ;
 $6233 ret           ;

; Display the main menu items to the screen.
;
; Used by the routine at #R$61d5.
@label=MenuDrawEntries
c$6234 ld de,$6261   ; Point #REGde to main menu colour attributes
 $6237 exx           ;
 $6238 ld hl,$6267   ; #REGhl'=Y (y-position of the menu item)
 $623b ld de,$626d   ; #REGde'=to the beginning of the menu strings
 $623e ld b,$06      ; #REGb'=loop counter for the 6 colour attribute bytes
; Flip-flop between normal/shadow registers: meaning one time we hit this EXX
; we are using the shadow registers, the next the normal registers.
*$6240 exx           ;
 $6241 ld a,(de)     ; #REGa=current colour attribute
 $6242 ld ($5dd6),a  ; Store menu colour attribute
 $6245 inc de        ;
 $6246 exx           ;
 $6247 push bc       ;
 $6248 ld a,(hl)     ;
 $6249 inc hl        ;
 $624a push hl       ;
 $624b ld h,a        ;
 $624c ld l,$30      ; #REGl'=indentation
 $624e call $62ca    ; Write line of text to screen
 $6251 exx           ;
 $6252 pop hl        ;
 $6253 pop bc        ;
 $6254 inc de        ;
 $6255 djnz $6240    ; Duel purpose loop: both colour attrs and menu items
@keep
 $6257 ld hl,$b800   ; Note: address is past 7FFF limit of 16K ZX Spectrum
 $625a ld de,$6043   ; Point #REGde to the copyright string
 $625d call $7134    ; Now display the copyright message
 $6260 ret           ;

; Colour attributes for main menu.
;
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Menu Item }
; { 1 | Jetpac Game Selection }
; { 2 | 1 Player Game }
; { 3 | 2 Player Game }
; { 4 | Keyboard }
; { 5 | Joystick }
; { 6 | Start Game }
; TABLE#
@label=menu_colour_table
b$6261 defb $47,$47,$47,$47,$47,$47

; Vertical position of each line of text in the main menu.
;
; #TABLE(default,centre,:w)
; { =h Byte(n) | =h Menu Item }
; { 1 | Jetpac Game Selection }
; { 2 | 1 Player Game }
; { 3 | 2 Player Game }
; { 4 | Keyboard }
; { 5 | Joystick }
; { 6 | Start Game }
; TABLE#
@label=menu_position_table
b$6267 defb $20,$38,$48,$58,$68,$98

; Text displayed on the main menu screen
@label=menu_text
t$626d defm "JETPAC GAME SELECTIO"
 $6281 defb $ce                    ; ASCII "N" & $80 (EOL)
 $6282 defm "1   1 PLAYER GAM"
 $6292 defb $c5                    ; ASCII "E" & $80 (EOL)
 $6293 defm "2   2 PLAYER GAM"
 $62a3 defb $c5                    ; ASCII "E" & $80 (EOL)
 $62a4 defm "3   KEYBOAR"
 $62af defb $c4                    ; ASCII "D" & $80 (EOL)
 $62b0 defm "4   JOYSTIC"
 $62bb defb $cb                    ; ASCII "K" & $80 (EOL)
 $62bc defm "5   START GAM"
 $62c9 defb $c5                    ; ASCII "E" & $80 (EOL)

; Write a single line of text on the main menu screen.
;
; Used by the routine at #R$6234.
;
; Input:HL Coordinate on the screen to display the string.
@label=MenuWriteText
c$62ca push hl       ; Backup coordinate
 $62cb call $72d0    ; #REGhl=coord to screen address (using #REGhl)
 $62ce ld a,($5dd6)  ; Current colour attribute
 $62d1 ex af,af'     ;
 $62d2 exx           ;
 $62d3 pop hl        ; Restore coordinate
 $62d4 call $71d6    ; #REGhl=coord to attribute file address (using #REGhl)
 $62d7 jp $7140      ; Display text string at #REGhl, using #REGa' colour

; Reset current and inactive player data on new game.
;
; Used by the routine at #R$62fe.
@label=ResetPlayerData
c$62da ld b,$02      ; Loop counter: current then inactive player
*$62dc push bc       ;
 $62dd xor a         ;
 $62de ld ($5df0),a  ; Reset player level
 $62e1 ld a,$04      ;
 $62e3 ld ($5df1),a  ; First player has 4 "remaining" lives
 $62e6 call $60a7    ; Reset the rocket modules
 $62e9 call $6144    ; Swap player game states
 $62ec pop bc        ;
 $62ed djnz $62dc    ; Repeat again for inactive player
 $62ef ld a,$05      ; {But now update inactive player to have 5 "remaining"
 $62f1 ld ($5df9),a  ; lives, not 4}
 $62f4 ld a,($5cf3)  ; Game options
 $62f7 and $01       ;
 $62f9 ret nz        ; Return if two player game
 $62fa ld ($5df9),a  ; else one player game, so inactive player has no lives
 $62fd ret           ;

; Start a new game.
;
; Resets all player, alien, and level data, then start a new game. Used by the
; routine at #R$61d5.
@label=NewGame
c$62fe ld hl,$5cf4   ; Starting at the Player 1 score
@nowarn
@keep
 $6301 ld bc,$6000   ; #REGb = counter, #REGc = fill byte
 $6304 call $7185    ; Clear memory, with null byte
 $6307 call $62da    ; Reset the player data
 $630a call $6954    ; Reset the self-modifying code
 $630d call $6083    ; Initialise a new level

; Reset stack pointer and enable interrupts before running main loop.
;
; If new item/alien was generated, this routine is called instead of MainLoop.
; .
; Used by the routine at #R$6971.
@label=MainLoopResetStack
@ssub=ld sp,$5ccb+$25 ; Set the stack pointer
c$6310 ld sp,$5cf0   ;
 $6313 ei            ;
 $6314 ld ix,$5d30   ; #REGix=Rocket object
 $6318 xor a         ;
 $6319 ld ($5dcb),a  ; Reset current alien number

; The main game loop.
;
; This routine is called until a new item/alien is generated, then #R$6310 is
; called.
; .
; Used by the routines at #R$6310, #R$692e and #R$6971.
;
; Input:IX address of main jump table
@label=MainLoop
c$631c ld a,($5c78)  ; {Compare SYSVAR_FRAMES and last_frame
 $631f ld c,a        ;
 $6320 ld a,($5dd4)  ;
 $6323 cp c          ; }
; Note: if we have EI here, then #R$692e will be called and DI executed.
 $6324 call nz,$692e ; If they're not equal, do frame update
; When one of the `main_jump_table` update routines RETurns, the new game actor
; routine will be called.
@nowarn
 $6327 ld hl,$6971   ; #REGhl=generate new actor routine
 $632a push hl       ; ...and push `ret` address to the stack.
; Execute one of the update routines using the value in IX.
 $632b ld hl,$633d   ; #REGhl=main jump table
 $632e ld a,(ix+$00) ; {Calculate the jump table offset
 $6331 rlca          ;
 $6332 and $7e       ; }

; Performs a main loop update jump.
;
; Used by the routines at #R$631c and #R$648b.
;
; Input:A Offset for jump table address.
;       HL Address to the jump table.
@label=PerformJump
c$6334 ld c,a        ;
 $6335 ld b,$00      ; #REGbc=offset: 34 max (size of jump table)
 $6337 add hl,bc     ; Set #REGhl to jump table address using offset
 $6338 ld a,(hl)     ; {Assign the jump address back to #REGhl
 $6339 inc hl        ;
 $633a ld h,(hl)     ;
 $633b ld l,a        ; }
 $633c jp (hl)       ; Use `jp` so `ret` calls the new actor/timer routine

; Main game loop jump table.
;
; Addresses for all the main routines to be updated per game loop.
@label=main_jump_table
w$633d defw $68e4    ; Frame rate limiter
 $633f defw $737d    ; Jetman Fly
 $6341 defw $753c    ; Jetman Walk
 $6343 defw $6d9c    ; Meteor Update
 $6345 defw $64e8    ; Collision Detection
 $6347 defw $6cbe    ; Crossed Space Ship Update
 $6349 defw $6bf8    ; Sphere Alien Update
 $634b defw $63a3    ; Jet Fighter Update
 $634d defw $687a    ; Animate Explosion
 $634f defw $66d0    ; Rocket Update
 $6351 defw $6690    ; Rocket Take off
 $6353 defw $66b4    ; Rocket Landing
 $6355 defw $681d    ; SFX Death: Enemy
 $6357 defw $6814    ; SFX Death: Player
 $6359 defw $6461    ; Check Item Collected
 $635b defw $6ab8    ; UFO Update
 $635d defw $6fc5    ; Animate Laser Beam
 $635f defw $6a35    ; Squidgy Alien Update

; Update the high score.
;
; If one of the players score is a new max score, then update the high score
; with that of the player with the highest score. Used by the routine at
; #R$60b7.
@label=UpdateHiScore
c$6361 ld hl,($5cf4) ; #REGhl=player 1 score
 $6364 ld de,($5cf7) ; #REGde=player 2 score
 $6368 ld a,l        ; {Swap the P1 LSB/MSB values so we can perform
 $6369 ld l,h        ; calculations on them.
 $636a ld h,a        ; }
 $636b ld a,e        ; {Swap the P2 LSB/MSB values so we can perform
 $636c ld e,d        ; calculations on them
 $636d ld d,a        ; }
 $636e and a         ; Reset the Carry flag
 $636f sbc hl,de     ;
 $6371 jr c,$637f    ; Jump if score P2 > P1, else
 $6373 jr nz,$639e   ; Jump if score P1 > P2, else P1==P2, so no jump
@ssub=ld a,($5cf4+$02)
 $6375 ld a,($5cf6)  ; {#REGe=3rd byte of the P1 score
 $6378 ld e,a        ; }
@ssub=ld a,($5cf7+$02) ; P2 score
 $6379 ld a,($5cf9)  ; #REGa=3rd byte of the P2 score
 $637c cp e          ;
 $637d jr c,$639e    ; Jump if score of P2 < P1 (set's #REGhl to P1 score)
; Inactive player has the highest score.
*$637f ld hl,$5cf7   ; #REGhl=P2 score
; Update the high score if the player score has beaten it.
*$6382 push hl       ;
 $6383 ld de,$5cf0   ; #REGde=high score
 $6386 ld b,$03      ; Loop counter (all 3 score bytes)
*$6388 ld a,(de)     ; #REGa = hi-score byte
 $6389 cp (hl)       ; Compare with player
 $638a jr c,$6394    ; If hi-score < player, update highscore score
 $638c jr nz,$6392   ; If hi-score != player (not equal), then RET
 $638e inc hl        ; else hi-score == player: next player byte
 $638f inc de        ; next high score byte
 $6390 djnz $6388    ; Repeat
*$6392 pop hl        ; Restores #REGhl to the highest player score
 $6393 ret           ;
; Sets the bytes for the high score with those from the player.
*$6394 pop hl        ;
 $6395 ld de,$5cf0   ; High Score
 $6398 ld bc,$0003   ;
 $639b ldir          ;
 $639d ret           ;
; Player 1 has the highest score.
*$639e ld hl,$5cf4   ; #REGhl=P1 score
 $63a1 jr $6382      ; Update HI score

; Update Jet Fighter.
;
; .
;
; Input:IX Alien object for one of the Jet Fighters.
@label=JetFighterUpdate
c$63a3 ld hl,$5dcb     ; {Increment current alien number
 $63a6 inc (hl)        ; }
 $63a7 call $6cb0      ; Update Alien direction
 $63aa ld a,(ix+$04)   ; Alien "moving" field
 $63ad ld hl,$0000     ;
 $63b0 bit 1,a         ; {Move if bit-1 is set
 $63b2 jr nz,$63ec     ; }
 $63b4 call $63d1      ; Check and update speed
 $63b7 ld a,($5d02)    ; #REGa=Jetman Y position
 $63ba sub $0c         ;
 $63bc cp (ix+$02)     ; {Update Alien speed if Jetman Y position-12 equals
 $63bf call z,$63d7    ; Alien Y position}
 $63c2 ld a,($5dcc)    ; #REGa=LSB of game timer
 $63c5 and $40         ;
 $63c7 jr z,$63cd      ; Move vertically if bit-6 is reset
*$63c9 inc h           ;
 $63ca inc h           ;
 $63cb inc h           ;
 $63cc inc h           ;
*$63cd dec h           ;
 $63ce dec h           ;
 $63cf jr $6406        ; Move vertically +2 or -2
; Decide if speed should be updated.
*$63d1 ld a,($5dce)    ; #REGa=random number
 $63d4 and $1f         ;
 $63d6 ret nz          ; Return if not zero
; Update speed.
*$63d7 set 1,(ix+$04)  ; Alien "moving" field
 $63db ld c,a          ; #REGc=Jetman Y position-12 ?
 $63dc ld a,($5dcc)    ; #REGa=LSB of game timer
 $63df add a,c         ;
 $63e0 and $7f         ;
 $63e2 or $20          ;
 $63e4 ld (ix+$05),a   ; Set new X speed value
 $63e7 ld (ix+$03),$47 ; Set "colour" to White
 $63eb ret             ;
; Move Jet Fighter horizontally.
*$63ec dec (ix+$05)    ; Decrement alien X speed
 $63ef jr z,$644a      ; Jet Fighter killed if X speed is zero
 $63f1 ld a,$04        ; #REGa=default speed
 $63f3 bit 6,(ix+$00)  ; Check bit-6 of Alien "direction"
 $63f7 jr z,$63fb      ;
 $63f9 neg             ;
*$63fb ld l,a          ; #REGl=$FC or $04?
; Target the player and move towards them.
 $63fc ld a,($5d02)    ; {Move upwards if Jetman Y position higher than Alien Y
 $63ff cp (ix+$02)     ; position
 $6402 jr c,$63cd      ; }
 $6404 jr $63c9        ; else, move down
; Move Jet Fighter vertically and horizontally.
*$6406 ld a,(ix+$00)   ; Alien "direction"
 $6409 and $c0         ; Reset FLY and WALK bits
 $640b or $03          ;
 $640d ld (ix+$00),a   ; Update "direction" value
 $6410 ld a,(ix+$01)   ; {Update Alien X position (#REGl is probably 3 or 4)
 $6413 add a,l         ;
 $6414 ld (ix+$01),a   ; }
 $6417 ld a,(ix+$02)   ; {Update Alien Y position
 $641a add a,h         ;
 $641b ld (ix+$02),a   ; }
 $641e call $7232      ; Update Actor Position X and draw
 $6421 call $7197      ; Colourize the sprite
 $6424 ld a,(ix+$02)   ; {Kill Fighter if Y position < $28
 $6427 cp $28          ;
 $6429 jr c,$644a      ; }
 $642b call $6e1b      ; Fire laser beam - returns #REGc
 $642e bit 0,c         ; {Kill if a laser hit the Alien
 $6430 jr nz,$644a     ; }
 $6432 call $75e8      ; Platform collision - returns #REGe
 $6435 bit 2,e         ; {Kill if Alien hit a platform
 $6437 jr nz,$644a     ; }
 $6439 call $6de9      ; Alien collision - returns #REGde
 $643c dec e           ;
 $643d jr z,$6456      ; Alien killed by collision
 $643f ld a,(ix+$00)   ; {Update Alien "direction"
 $6442 and $c0         ;
 $6444 or $07          ;
 $6446 ld (ix+$00),a   ; }
 $6449 ret             ;
; Jet Fighter is dead. Added score and make exploding sound.
*$644a ld bc,$0055     ; 55 points for a dead jet fighter (decimal value)
 $644d call $70c2      ; Add points to score
 $6450 call $67b6      ; Exploding jet fighter SFX - actually Thruster SFX!
 $6453 jp $685d        ; Update current alien state

; Alien SFX when killed by collision.
;
; Reset anim state and set SFX params #2.
; .
; Used by the routines at #R$63a3, #R$6a35, #R$6ab8, #R$6bf8, #R$6cbe and
; #R$6d9c.
@label=AlienCollisionAnimSfx
c$6456 call $685d    ; Update actor state
 $6459 ld a,$01      ; {Play explosion sound with SFX type #2
 $645b call $67fd    ; }
 $645e jp $683e      ; Animate explosion

; Jetman collects a collectible item.
;
; .
;
; Input:IX Collectible item object
@label=ItemCheckCollect
c$6461 call $72ef      ; Update Actor position direction
 $6464 call $75e8      ; Platform collision - returns #REGe
 $6467 bit 2,e         ; {Increment item Y position if bit-2 is set
 $6469 jr nz,$6471     ;
 $646b inc (ix+$02)    ;
 $646e inc (ix+$02)    ; }
*$6471 call $6de9      ; Alien collision - returns #REGe
 $6474 dec e           ;
 $6475 jr nz,$648b     ; Drop new collectible item if #REGe > 0
 $6477 xor a           ; Reset #REGa
 $6478 call $64ae      ; #REGhl=sprite address
 $647b call $7268      ; Destroy the collected item
 $647e ld (ix+$00),$00 ; Set type as unused
 $6482 ld bc,$0250     ; 250 points to add to score (decimal value)
 $6485 call $70c2      ; Add points to score
 $6488 jp $67d2        ; SFX for item collect (and return)

; Drop a new collectible item.
;
; Used by the routine at #R$6461.
;
; Input:IX Collectible item object
@label=ItemDropNew
c$648b ld a,(ix+$06) ; Jump table offset
 $648e and $0f       ; Values: 0, 2, 4, 6, or 8
 $6490 ld hl,$6496   ; #REGhl=item drop jump table
 $6493 jp $6334      ; Execute the jump using #REGhl address

; Item drop jump table.
@label=item_drop_jump_table
w$6496 defw $64a0    ; Drop Gold bar collectible
 $6498 defw $64c2    ; Drop chemical based collectible
 $649a defw $64c2    ; Drop chemical based collectible
 $649c defw $64bc    ; Drop green coloured collectible
 $649e defw $64d7    ; Drop collectible with random colour

; Drop a gold bar collectible item.
;
; .
;
; Input:IX Collectible item object
@label=ItemDropGoldBar
c$64a0 ld (ix+$03),$46 ; Set colour to GOLD

; Display a collectible sprite.
;
; Used by the routines at #R$64bc, #R$64c2 and #R$64d7.
@label=ItemDisplaySprite
c$64a4 xor a         ;
 $64a5 call $64ae    ; #REGde=item sprite address
 $64a8 call $7226    ; Update the item sprite
 $64ab jp $7197      ; Colourize the sprite

; Sprite offset using colour attribute.
;
; Used by the routines at #R$6461, #R$64a4 and #R$6514.
@label=ItemGetSpriteAddressAttrOffset
c$64ae add a,(ix+$06) ;

; Get address for collectible sprite.
;
; Used by the routine at #R$66fc.
;
;  Input:A Offset for the desired sprite.
; Output:DE Address for a sprite.
@label=ItemGetSpriteAddress
c$64b1 ld hl,$678c   ; Sprite lookup table
 $64b4 ld c,a        ; {Add offset to base address
 $64b5 ld b,$00      ;
 $64b7 add hl,bc     ; }
 $64b8 ld e,(hl)     ; {Assign sprite address to #REGde
 $64b9 inc hl        ;
 $64ba ld d,(hl)     ; }
 $64bb ret           ;

; Drop a Plutonium collectible item.
;
; .
;
; Input:IX Collectible item object.
@label=ItemDropPlutonium
c$64bc ld (ix+$03),$44 ; Set the colour to green
 $64c0 jr $64a4        ; Display item sprite

; Drop a chemical based item, flashing items radiation and plutonium.
;
; .
;
; Input:IX Collectible item object.
@label=ItemDropChemical
c$64c2 ld a,($5dcc)    ; Game timer
 $64c5 and $1f         ;
 $64c7 cp $18          ;
 $64c9 jr nc,$64d1     ; Use cyan colour and display sprite
; Flashing items: hidden.
 $64cb ld (ix+$03),$00 ; Set the colour to black
 $64cf jr $64a4        ; Display the item sprite
; Flashing items: visible.
*$64d1 ld (ix+$03),$45 ; Set the colour to cyan
 $64d5 jr $64a4        ; Display the item sprite

; Drop a random coloured collectible item.
;
; Set the sprite to a random colour based on it's ID, which means colour values
; will be between $41 and $47.
;
; Input:IX Collectible item object.
@label=ItemDropRandomColour
c$64d7 ld a,($5dcc)  ; Game timer
 $64da rrca          ;
 $64db rrca          ;
 $64dc and $07       ;
 $64de jr nz,$64e1   ; Jump if #REGa is now 1-7
 $64e0 inc a         ;
*$64e1 or $40        ; Make sure colour value is > $40
 $64e3 ld (ix+$03),a ; Set the colour to between $41 and $47
 $64e6 jr $64a4      ; Display the item sprite

; Collision detection for collectible items / rocket modules.
;
; .
;
; Input:IX Collectible item object.
@label=CollisionDetection
c$64e8 call $72ef    ; Update Actor position direction
 $64eb ld a,(ix+$04) ; #REGa=item "state"
 $64ee bit 2,a       ; {Pick up rocket module if bit-2 set
 $64f0 jp nz,$6565   ; }
 $64f3 bit 1,a       ; {Carrying rocket module/fuel if bit-1 set
 $64f5 jr nz,$6541   ; }
 $64f7 bit 0,a       ; {Draw sprite if bit-0 reset
 $64f9 jr z,$6514    ; }
 $64fb call $6de9    ; Check for alien collision - returns #REGe
 $64fe dec e         ; {Collect rocket module if #REGe == 0
 $64ff jr z,$6523    ; }
 $6501 call $75e8    ; Platform collision - returns #REGe
 $6504 bit 2,e       ; {Draw sprite if bit-2 set
 $6506 jr nz,$650e   ; }

; Increment Y position and draw sprite.
;
; Used by the routine at #R$6565.
@label=IncYRedrawSprite
c$6508 inc (ix+$02)  ;
 $650b inc (ix+$02)  ;

; Redraw a sprite.
;
; Used by the routines at #R$64e8, #R$6523 and #R$6541.
@label=RedrawSprite
c$650e call $7232    ; Update actor and draw sprite
 $6511 jp $7197      ; Colourize the sprite

; Gets collectible ID based on the current user level.
;
; Used by the routine at #R$64e8.
@label=GetCollectibleID
c$6514 ld a,($5df0)  ; Current player level
 $6517 rrca          ;
 $6518 and $06       ; There are only 6 collectibles?
 $651a call $64ae    ; #REGde=collectible item sprite address
 $651d call $7263    ; Erase an item sprite
 $6520 jp $7197      ; Colourize the sprite

; Collect Rocket module or fuel pod.
;
; Module is collected after player collides with it. Used by the routine at
; #R$64e8.
;
; Input:IX Rocket module object.
@label=CollectRocketItem
c$6523 set 1,(ix+$04) ; Module "state"
 $6527 call $726d     ; Find and destroy the sprite (returns #REGde)
 $652a ld bc,$0100    ; 100 points to add to score (decimal value)
 $652d call $70c2     ; Add points to score
 $6530 call $67cc     ; SFX for collecting fuel
 $6533 ld hl,($5d01)  ; {Update module position so it becomes attached to the
 $6536 ld (ix+$01),l  ; player via the Jetman Y,X positions
 $6539 ld (ix+$02),h  ; }
 $653c call $72ef     ; Update sprite X position
 $653f jr $650e       ; Colourize the sprite

; Carry a collected rocket module/fuel pod.
;
; Ensure the rocket module/fuel pod remains attached to the foot of the Jetman
; sprite. Used by the routine at #R$64e8.
;
; Input:IX Rocket module object.
@label=CarryRocketItem
c$6541 ld hl,($5d01)  ; {Update module position so it becomes attached to the
 $6544 ld (ix+$01),l  ; player via the Jetman Y,X positions
 $6547 ld (ix+$02),h  ; }
@ssub=ld a,($5d30+$01) ; Rocket X position
 $654a ld a,($5d31)   ;
 $654d sub (ix+$01)   ; Subtract module X position
 $6550 jp p,$6555     ; If already negative, jump
 $6553 neg            ; else make a negative value
*$6555 cp $06         ; {Draw sprite if #REGa >= 6
 $6557 jr nc,$650e    ; }
 $6559 set 2,(ix+$04) ; Set module "state" to collected
@ssub=ld a,($5d30+$01) ; Rocket: X position
 $655d ld a,($5d31)   ;
 $6560 ld (ix+$01),a  ; Update module X position to be same as Rocket position
 $6563 jr $650e       ; Update module and draw sprite

; Pick up and carry a rocket module/fuel pod.
;
; Used by the routine at #R$64e8.
;
; Input:IX Collectible item object - rocket module or fuel pod.
@label=PickupRocketItem
c$6565 ld a,(ix+$06)   ; Item sprite jump table offset
 $6568 cp $18          ;
 $656a jr z,$6597      ; Jump to delivery check if a fuel pod?
 $656c sla a           ;
 $656e add a,(ix+$02)  ; Add item Y position
 $6571 cp $b7          ;
 $6573 jp c,$6508      ; Increment item Y position and draw sprite if < 183
@ssub=ld a,($5d38+$04) ;
 $6576 ld a,($5d3c)    ;
 $6579 or $01          ;
@ssub=ld ($5d38+$04),a ; Set module "state" to collected
 $657b ld ($5d3c),a    ;
@ssub=ld a,($5d30+$04) ; #REGa=Rocket "state" value
 $657e ld a,($5d34)    ;
 $6581 inc a           ;
@ssub=ld ($5d30+$04),a ; Update rocket "state" value
 $6582 ld ($5d34),a    ;
 $6585 ld a,(ix+$06)   ; Item sprite jump table offset
 $6588 add a,$08       ;
 $658a call $6ec2      ; Copy rocket sprite to buffers
*$658d call $726d      ; Find and destroy current sprite
 $6590 ld (ix+$00),$00 ; Set item type to unused
 $6594 jp $67c6        ; SFX for rocket building
; Check if fuel pod delivered to ship, and increment count if so.
*$6597 ld a,(ix+$02)   ; Item Y position of fuel pod
 $659a cp $b0          ; Has it reached the rocket yet?
 $659c jp c,$6508      ; Move the fuel cell down one pixel if not
@ssub=ld a,($5d30+$05) ; #REGa=rocket fuel pod count
 $659f ld a,($5d35)    ;
 $65a2 inc a           ;
@ssub=ld ($5d30+$05),a ; Increment rocket fuel pod count
 $65a3 ld ($5d35),a    ;
 $65a6 jr $658d        ; Loop back and repeat

; Release new collectible item.
;
; Used by the routine at #R$6971.
@label=ItemNewCollectible
c$65a8 ld a,($5d00)  ; Jetman direction
 $65ab and $3f       ;
 $65ad ret z         ; Return if not one of the 6 directions
 $65ae cp $03        ;
 $65b0 ret nc        ; Return if >= 3 (all movement except up right?)
 $65b1 ld hl,$603b   ; #REGhl=default item state
 $65b4 ld de,$5d40   ; #REGde=collectible object
 $65b7 ld bc,$0008   ;
 $65ba ld a,(de)     ; #REGa=item type
 $65bb and a         ;
 $65bc ret nz        ; Return if currently in use
 $65bd ld a,($5dcc)  ; Game timer
 $65c0 and $7f       ;
 $65c2 ret nz        ; Return if between 1-127
 $65c3 ldir          ;
 $65c5 call $65db    ; #REGa=column to drop item
@ssub=ld ($5d40+$01),a ; Update item X position
 $65c8 ld ($5d41),a  ;
 $65cb ld a,r        ; Get random number
 $65cd and $0e       ; #REGa=2, 4, 6, 8, 10, 12, or 14
 $65cf bit 3,a       ; {Jump if bit-3 is already reset
 $65d1 jr z,$65d5    ; }
 $65d3 and $08       ; else set bit-3
*$65d5 or $20        ; Make sure bit-5 (32) is set
@ssub=ld ($5d40+$06),a ; Update item with new jump table offset
 $65d7 ld ($5d46),a  ;
 $65da ret           ;

; Calculate column on which to drop a new collectible item/fuel pod.
;
; Used by the routines at #R$65a8 and #R$65f9.
;
; Ouput:A Column position.
@label=ItemCalcDropColumn
c$65db ld hl,$65e9   ; #REGhl=item drop position table
 $65de ld a,($5dce)  ; #REGa=random number
 $65e1 and $0f       ;
 $65e3 ld c,a        ; {#REGbc = byte offset (0-15)
 $65e4 ld b,$00      ; }
 $65e6 add hl,bc     ; Add offset
 $65e7 ld a,(hl)     ; Set #REGa to position
 $65e8 ret           ;

; Horizontal column positions for dropping collectibles.
@label=item_drop_positions_table
b$65e9 defb $08,$20,$28,$30,$38,$40,$58,$60
 $65f1 defb $78,$80,$88,$c0,$e0,$08,$58,$60

; Drop a new fuel pod collectible.
;
; Used by the routine at #R$6971.
@label=ItemNewFuelPod
c$65f9 ld a,($5d00)  ; Jetman direction
 $65fc and $3f       ;
 $65fe ret z         ; Return if not one of the 6 directions
 $65ff cp $03        ;
 $6601 ret nc        ; Return if >= 3 (all movement except up right?)
 $6602 ld hl,$6033   ; #REGhl=default rocket module state
 $6605 ld de,$5d38   ; #REGde=rocket module object
 $6608 ld bc,$0008   ;
 $660b ld a,(de)     ; {Return if currently in use
 $660c and a         ;
 $660d ret nz        ; }
@ssub=ld a,($5d30+$05) ; #REGa=Rocket fuel Pod count
 $660e ld a,($5d35)  ;
 $6611 cp $06        ;
 $6613 ret nc        ; Return if fuel collected >= 6
 $6614 ld a,($5dcc)  ; Game timer
 $6617 cpl           ;
 $6618 and $0f       ;
 $661a ret nz        ; Return if #REGa is between 1-15
 $661b ldir          ;
 $661d call $65db    ; #REGa=column to drop item
@ssub=ld ($5d38+$01),a ; Update fuel pod X position
 $6620 ld ($5d39),a  ;
 $6623 ret           ;

; Reset the Rocket modules state data ready for next level.
;
; After the rocket hits top of screen this routine resets all the collectibles,
; aliens, and player states for that level. Used by the routine at #R$6690.
@label=RocketModulesReset
c$6624 ld hl,$5d38   ; #REGhl=rocket module
 $6627 ld b,$0c      ; Loop counter

; Set objects as inactive.
;
; Used by the routines at #R$60b7 and #R$6624.
;
; Input:B Loop counter: either $0A or $0C.
;       HL Object to be updated: fuel pod or thruster animation.
@label=SetObjectInactive
c$6629 ld de,$0008   ; Increment value
*$662c ld (hl),$00   ; Reset first byte of object
 $662e add hl,de     ; Set #REGhl to beginning of next object
 $662f djnz $662c    ;
 $6631 ret           ;

; Animate the rocket flame sprites.
;
; Used by the routines at #R$6690 and #R$66b4.
;
; Input:IX Rocket object
@label=RocketAnimateFlames
c$6632 ld a,(ix+$02)   ; {Add 21 to rocket Y position
 $6635 add a,$15       ;
 $6637 ld (ix+$02),a   ; }
@ssub=ld hl,$5dc0+$01 ; #REGhl=Actor Y position
 $663a ld hl,$5dc1     ;
 $663d ld a,(hl)       ; {Add 21 to actor Y position
 $663e add a,$15       ;
 $6640 ld (hl),a       ; }
 $6641 ld a,(ix+$02)   ; {If near ground, turn off flame sprites
 $6644 cp $b8          ;
 $6646 jr z,$6681      ; }
 $6648 jr nc,$666c     ; If >= 184, just update flame sprite vars
 $664a ld a,($5dcc)    ; Game timer
 $664d and $04         ;
 $664f jr nz,$667c     ; #REGde=flame sprite #1 if bit-3 is set
 $6651 ld de,$7f7a     ; else #REGde=flame sprite #2
; Draw the flame sprites.
*$6654 push de         ;
 $6655 ld de,$7f57     ; {Destroy flame sprite #1
 $6658 call $7268      ; }
 $665b ld de,$7f7a     ; {Destroy flame sprite #2
 $665e call $7268      ; }
 $6661 pop de          ;
 $6662 call $7263      ; Erase and animate actor sprite
 $6665 ld (ix+$03),$42 ; Set flame sprite colour to Red
 $6669 call $7197      ; Colourize the sprite
; Update Rocket and Actor Y positions.
*$666c ld a,(ix+$02)   ; {Subtract $15 from rocket Y position
 $666f sub $15         ;
 $6671 ld (ix+$02),a   ; }
@ssub=ld hl,$5dc0+$01 ; #REGhl=Actor Y position
 $6674 ld hl,$5dc1     ;
 $6677 ld a,(hl)       ; {Subtract 21 from actor Y position
 $6678 sub $15         ;
 $667a ld (hl),a       ; }
 $667b ret             ;
; Set first rocket flame sprite to be displayed.
*$667c ld de,$7f57     ; Rocket flame sprite #1
 $667f jr $6654        ; Draw flame sprite
; Turn off the rocket flame sprites and update sprite variables.
*$6681 ld de,$7f57     ; {Destroy flame sprite #1
 $6684 call $7268      ; }
 $6687 ld de,$7f7a     ; {Destroy flame sprite #2
 $668a call $7268      ; }
 $668d jp $666c        ; Update sprite variables

; Rocket ship is taking off.
;
; .
;
; Input:IX Rocket object.
@label=RocketTakeoff
c$6690 call $72ef      ; Update Actor position direction
 $6693 dec (ix+$02)    ; Decrement Y position
 $6696 call $67b6      ; Thruster SFX
 $6699 call $6632      ; Animate rocket flame sprites
 $669c ld a,(ix+$02)   ; {Check if rocket has reached top of screen
 $669f cp $28          ; }
 $66a1 jr nc,$66fc     ; Update rocket colour if not
; Rocket has reached top of screen - set up next level.
 $66a3 ld hl,$5df0     ; {Increment current player level
 $66a6 inc (hl)        ; }
 $66a7 call $6624      ; Reset rocket ready for next level
 $66aa inc (ix+$00)    ; Set Rocket "move" state to down
 $66ad ld (ix+$05),$00 ; Reset fuel pod counter
 $66b1 jp $6083        ; New level

; Rocket ship is landing.
;
; .
;
; Input:IX Rocket object.
@label=RocketLanding
c$66b4 call $72ef      ; Update Actor position direction
 $66b7 inc (ix+$02)    ; Increment Y position
 $66ba call $67b6      ; Thruster SFX
 $66bd call $6632      ; Animate rocket flame sprites
 $66c0 ld a,(ix+$02)   ; {Check if rocket has landed
 $66c3 cp $b7          ; }
 $66c5 jr c,$66fc      ; Update rocket colour if not (and RET)
; Rocket has landed!
 $66c7 ld (ix+$00),$09 ; Set Rocket "move" state to default (on pad)
 $66cb call $6174      ; Initialise the player state
 $66ce jr $66fc        ; Update rocket colour (and RET)

; Update the rocket ship.
;
; .
;
; Input:IX Rocket object.
@label=RocketUpdate
c$66d0 call $72ef      ; Update Actor position direction
 $66d3 call $6de9      ; #REGe=Alien collision result: $00 or $01
 $66d6 dec e           ; {Update rocket colour if not zero (and RET)
 $66d7 jr nz,$66fc     ; }
 $66d9 ld a,(ix+$05)   ; {Update rocket colour if fuel pod counter < 6 (and
 $66dc cp $06          ; RET)
 $66de jr c,$66fc      ; }
 $66e0 inc (ix+$00)    ; Set Rocket "move" state to up
 $66e3 push ix         ;
 $66e5 ld ix,$5d00     ; #REGix=Jetman object
 $66e9 call $72ef      ; Update Jetman position direction
 $66ec call $726d      ; Jetman, find and destroy
 $66ef ld (ix+$00),$00 ; Reset Jetman direction
 $66f3 pop ix          ; Restore #REGix to be the rocket object
 $66f5 ld hl,$5df1     ; {Increment current player lives
 $66f8 inc (hl)        ; }
 $66f9 jp $706d        ; Display player lives (and RET)

; Update Rocket ship colour.
;
; Colouring is based on the number of fuel pods collected. This routine is
; never CALLed (only via JR), so the last RET forces the calling routine to
; return. Used by the routines at #R$6690, #R$66b4 and #R$66d0.
;
; Input:IX Rocket object.
@label=UpdateRocketColour
c$66fc ld l,(ix+$01)   ; Rocket X position
 $66ff ld h,(ix+$02)   ; Rocket Y position
 $6702 push hl         ;
 $6703 ld a,(ix+$04)   ; #REGa=colour attribute
 $6706 ld b,a          ; {Set loop counter
 $6707 ld c,$00        ; }
; Draw all collected rocket modules.
*$6709 push bc         ;
 $670a ld a,($5df0)    ; #REGa=player level
 $670d rrca            ; {Calculate which sprite to use for the current level
 $670e rrca            ;
 $670f and $03         ;
 $6711 or c            ;
 $6712 sla a           ; }
 $6714 call $64b1      ; #REGde=item address from lookup table using #REGa
 $6717 call $7226      ; Update actor position using #REGde
 $671a pop bc          ; Restore loop counter
 $671b ld a,(ix+$02)   ; {Subtract 16 from a rocket Y position
 $671e sub $10         ;
 $6720 ld (ix+$02),a   ; }
@ssub=ld a,($5dc0+$01) ; #REGa=Actor Y position
 $6723 ld a,($5dc1)    ;
 $6726 sub $10         ; Subtract 16 from Actor Y position
@ssub=ld ($5dc0+$01),a ; Update Actor Y position
 $6728 ld ($5dc1),a    ;
 $672b ld a,c          ;
 $672c add a,$04       ;
 $672e ld c,a          ;
 $672f djnz $6709      ; Loop and update rocket/actor again
 $6731 ld a,$02        ;
@ssub=ld ($5dc0+$04),a ; Actor width = 2
 $6733 ld ($5dc4),a    ;
 $6736 xor a           ;
@ssub=ld ($5dc0+$03),a ; Actor height = 0 (?)
 $6737 ld ($5dc3),a    ;
 $673a pop hl          ;
 $673b ld (ix+$02),h   ; Update rocket Y position: only Y changed in loop above
 $673e ld ($5dcf),hl   ; Update current Actor Y,X coords
; Colour the rocket modules based on collected fuel pod count.
 $6741 ld b,(ix+$04)   ; {Rocket "state"
 $6744 sla b           ;
 $6746 ld a,b          ; }
 $6747 cp $06          ; {if value < 6, or the fuel pod counter is zero, then
 $6749 jr c,$6772      ; set rocket colour to white and redraw
 $674b ld a,(ix+$05)   ;
 $674e and a           ;
 $674f jr z,$6772      ; }
 $6751 cp $06          ; Check if all fuel collected (is checked at 6760)
 $6753 push af         ; Preserve Carry (no care for #REGa)
 $6754 ld a,($5dcc)    ; Game timer
 $6757 rrca            ;
 $6758 rrca            ;
 $6759 and $04         ;
 $675b or $43          ;
 $675d ld c,a          ;
 $675e pop af          ; Restore Carry value (from 6751 check above)
 $675f ld a,c          ;
 $6760 jr nc,$6774     ; Colour all sprites if all fuel has been collected
 $6762 ld b,(ix+$05)   ; else use fuel pod count as loop counter
 $6765 ld (ix+$03),$43 ; Set colour to Magenta
 $6769 call $677a      ; Update sprite colour
; Set part of rocket back to white based on amount of uncollected fuel pods.
 $676c ld a,$06        ; #REGa=max possible fuel pods
 $676e sub (ix+$05)    ; Subtract remaining fuel pod count
 $6771 ld b,a          ; Set loop counter
*$6772 ld a,$47        ; {Set Rocket colour to white
*$6774 ld (ix+$03),a   ; }
 $6777 jp $677a        ; Redundant JP!
*$677a push bc         ;
 $677b call $7197      ; Colourize the sprite
 $677e pop bc          ;
 $677f ld hl,($5dcf)   ; #REGhl=current rocket sprite coords
 $6782 ld a,h          ; {Update Y position
 $6783 sub $08         ;
 $6785 ld h,a          ; }
 $6786 ld ($5dcf),hl   ; Update current rocket sprite coords
 $6789 djnz $677a      ; Loop and continue colouring
 $678b ret             ;

; Rocket and collectible sprite address lookup table.
@label=collectible_sprite_table
w$678c defw $7c99    ; Offset: $00 - Rocket #1: Bottom
 $678e defw $7d02    ; Offset: $02 - Rocket #5: Bottom
 $6790 defw $7c30    ; Offset: $04 - Rocket #3: Bottom
 $6792 defw $7d6b    ; Offset: $06 - Rocket #4: Bottom
 $6794 defw $7cbc    ; Offset: $08 - Rocket #1: Middle
 $6796 defw $7d25    ; Offset: $0A - Rocket #5: Middle
 $6798 defw $7c53    ; Offset: $0C - Rocket #3: Middle
 $679a defw $7d8e    ; Offset: $0E - Rocket #4: Middle
 $679c defw $7cdf    ; Offset: $10 - Rocket #1: Top
 $679e defw $7d48    ; Offset: $12 - Rocket #5: Top
 $67a0 defw $7c76    ; Offset: $14 - Rocket #3: Top
 $67a2 defw $7db1    ; Offset: $16 - Rocket #4: Top
 $67a4 defw $7de7    ; Offset: $18 - Fuel Cell
 $67a6 defw $7de7    ; Offset: $1A - Fuel Cell
 $67a8 defw $7de7    ; Offset: $1C - Fuel Cell
 $67aa defw $7de7    ; Offset: $1E - Fuel Cell
 $67ac defw $7dd4    ; Offset: $20 - Gold Bar
 $67ae defw $7e00    ; Offset: $22 - Radiation
 $67b0 defw $7e19    ; Offset: $24 - Chemical Weapon
 $67b2 defw $7e36    ; Offset: $26 - Plutonium
 $67b4 defw $7e4b    ; Offset: $28 - Diamond

; Rocket thruster SFX, and Jet Fighter explosions.
;
; Used by the routines at #R$63a3, #R$6690 and #R$66b4.
;
; Input:IX Jetman or Rocket object.
@label=SfxThrusters
c$67b6 ld a,(ix+$02) ; Y position
 $67b9 rrca          ; {Change pitch based on vertical position
 $67ba rrca          ;
 $67bb rrca          ;
 $67bc rrca          ;
 $67bd and $7f       ;
 $67bf or $40        ; }
 $67c1 ld d,a        ; Pitch
 $67c2 ld c,$10      ; Duration
 $67c4 jr $67db      ; Play square wave sound

; SFX for ship building.
;
; Activated when ship module is dropped, or fuel cell touches the rocket base.
@label=SfxRocketBuild
c$67c6 ld d,$20      ; Pitch
 $67c8 ld c,$50      ; Duration
 $67ca jr $67db      ; Play square wave sound

; SFX for collecting a fuel cell.
;
; Used by the routine at #R$6523.
@label=SfxPickupFuel
c$67cc ld d,$50      ; Pitch
 $67ce ld c,$28      ; Duration
 $67d0 jr $67db      ; Play square wave sound

; SFX for collecting an item, and when Jetman appears on-screen.
;
; Used by the routines at #R$6461 and #R$737d.
@label=SfxPickupItem
c$67d2 ld d,$30      ; Pitch
 $67d4 ld c,$40      ; Duration

; Play square wave sound.
;
; Used by the routine at #R$67db.
@label=PlaySquareWave1
c$67d6 ld a,$10      ;
 $67d8 out ($fe),a   ;
 $67da ld b,d        ;

; Play square wave sound, starting with silence.
;
; Used by the routines at #R$67b6, #R$67c6 and #R$67cc.
;
; Input:D Sound frequency
;       C Sound duration
@label=PlaySquareWav2
c$67db djnz $67db    ; Play sound/silence for desired length
 $67dd xor a         ; {Turn speaker OFF for desired duration
 $67de out ($fe),a   ;
 $67e0 ld b,d        ;
*$67e1 djnz $67e1    ; }
 $67e3 dec c         ; Decrement duration
 $67e4 jr nz,$67d6   ; Repeat until duration is zero
 $67e6 ret           ;

; SFX for Laser Fire.
;
; Used by the routine at #R$6f86.
@label=SfxLaserFire
c$67e7 ld c,$08      ; Pitch/duration
*$67e9 ld b,c        ;
*$67ea djnz $67ea    ;
 $67ec ld a,$10      ; {Play sound for desire duration
 $67ee out ($fe),a   ;
 $67f0 ld b,c        ;
*$67f1 djnz $67f1    ; }
 $67f3 xor a         ;
 $67f4 out ($fe),a   ; Turn speaker OFF
 $67f6 inc c         ; Increment pitch
 $67f7 ld a,c        ;
 $67f8 cp $38        ;
 $67fa jr nz,$67e9   ; Repeat until pitch is $38
 $67fc ret           ;

; Set the default explosion SFX params.
;
; The audio is triggered from the #R$6971 routine using the
; explosion_sfx_params data.
; .
; Used by the routines at #R$6456, #R$6bf1, #R$6d5c and #R$6d9c.
;
; Input:A selects SFX #1 or #2.
@label=SfxSetExplodeParams
c$67fd ld c,a        ;
 $67fe sla c         ; #REGc=0 or 2
 $6800 ld b,$00      ;
 $6802 ld de,$5d28   ; #REGde=explosion SFX params
 $6805 ld hl,$6810   ; #REGhl=explosion SFX param defaults
 $6808 add hl,bc     ; Set offset: first or second pair of bytes
 $6809 ld a,(hl)     ; {Copy defaults to the params
 $680a ld (de),a     ;
 $680b inc hl        ;
 $680c inc de        ;
 $680d ld a,(hl)     ;
 $680e ld (de),a     ; }
 $680f ret           ;

; Default explosion SFX parameters.
;
; These parameters are used in pairs: SFX #1 is used for most aliens, while SFX
; #2 is used for player, sphere alien, and crossed ship.
; #TABLE(default,centre,:w)
; { =h Bytes(n) | =h Parameter }
; { 1 | SFX 1: Frequency }
; { 2 | SFX 1: Duration }
; { 3 | SFX 2: Frequency }
; { 4 | SFX 2: Duration }
; TABLE#
@label=explosion_sfx_defaults
b$6810 defb $0c,$04,$0d,$04

; Play Jetman death SFX.
;
; .
;
; Input:IX The explosion SFX params array.
@label=SfxJetmanDeath
c$6814 dec (ix+$01)  ; Decrement the SFX duration
 $6817 jr z,$6839    ; Stop playing SFX if duration is zero
 $6819 ld c,$10      ; Frequency = 16
 $681b jr $6828      ; Play explosion SFX

; Play enemy death SFX.
;
; .
;
; Input:IX The explosion SFX params array.
@label=SfxEnemyDeath
c$681d dec (ix+$01)  ; Decrement the SFX duration
 $6820 jr z,$6839    ; Stop playing SFX if duration is zero
 $6822 ld a,(ix+$01) ;
 $6825 add a,$18     ;
 $6827 ld c,a        ; Frequency = Duration + 24

; Plays the explosion sound effect.
;
; The note pitch goes from `low` to `high`.
; .
; Used by the routine at #R$6814.
;
; Input:C note frequency.
@label=SfxPlayExplosion
c$6828 ld a,$10      ;
 $682a out ($fe),a   ; Turn speaker ON
 $682c ld b,c        ; Set duration
*$682d djnz $682d    ; Note continues for the frequency duration
 $682f xor a         ;
 $6830 out ($fe),a   ; Turn speaker OFF
 $6832 ld b,c        ;
*$6833 djnz $6833    ; Silence for the frequency duration
 $6835 dec c         ; Decrement frequency (higher pitch)
 $6836 jr nz,$6828   ; Repeat until frequency is zero
 $6838 ret           ;

; Sound has finished playing.
;
; Used by the routines at #R$6814 and #R$681d.
;
; Input:IX The explosion SFX params array.
@label=SfxFinishReturn
c$6839 ld (ix+$00),$00 ; Set frequency to zero
 $683d ret             ;

; Animate explosion after killing an alien.
;
; Used by the routine at #R$6456.
@label=ExplosionAfterKill
c$683e push ix       ;
 $6840 ld ix,$5d80   ; Jetman explosion animation object
 $6844 ld hl,$5d00   ; Jetman object
 $6847 ld c,(hl)     ; Assign direction to temp variable
 $6848 inc hl        ; Animation X position
 $6849 ld a,(hl)     ; {Set explosion X position to match Jetman X position
 $684a ld (ix+$01),a ; }
 $684d inc hl        ; {Set explosion Y position to match Jetman
 $684e ld a,(hl)     ;
 $684f ld (ix+$02),a ; }
 $6852 ld a,c        ; #REGa=Jetman direction
 $6853 call $6874    ; Reset actor, which also sets anim object "state" to $01
 $6856 pop ix        ;
 $6858 xor a         ;
 $6859 ld ($5d00),a  ; Reset Jetman direction to not moving
 $685c ret           ;

; Enable animation, state false.
;
; Used by the routines at #R$63a3, #R$6456, #R$6bf1, #R$6d5c, #R$6d9c and
; #R$753c.
;
; Input:IX Animation object.
@label=AnimationStateReset
c$685d ld a,(ix+$00)   ; Animating state
 $6860 and $c0         ;
 $6862 or $03          ;
 $6864 ld (ix+$05),$00 ; Set "state" to un-animated

; Enable animation and reset frame count.
;
; Used by the routine at #R$6874.
;
; Input:A New direction value.
;       IX Animation object.
@label=EnableAnimationState
c$6868 ld (ix+$06),a   ; Update direction
 $686b ld (ix+$00),$08 ; Set animating to "yes"
 $686f ld (ix+$04),$00 ; Reset frame count
 $6873 ret             ;

; Enable animation, state true.
;
; Used by the routine at #R$683e.
;
; Input:A New direction value.
;       IX Animation object.
@label=AnimationStateSet
c$6874 ld (ix+$05),$01 ; Set "state" to animating
 $6878 jr $6868        ;

; Animates the explosion sprites.
;
; .
;
; Input:IX Explosion animation object
@label=AnimateExplosion
c$687a ld hl,$5dcb     ; {Increment current alien number
 $687d inc (hl)        ; }
 $687e ld c,(ix+$04)   ; #REGc=explosion animation frame
 $6881 ld b,(ix+$05)   ; #REGb=explosion animation state
 $6884 ld a,($5dcc)    ; Game timer
 $6887 and b           ;
 $6888 jr nz,$688d     ; {Increment frame if timer&state is zero
 $688a inc (ix+$04)    ; }
*$688d ld a,c          ; #REGa=original frame count
 $688e sla c           ; Multiply by 2 (addresses are two-bytes)
 $6890 ld b,$00        ;
 $6892 ld hl,$68d8     ; #REGhl=explosion sprite lookup table
 $6895 add hl,bc       ; Set offset
 $6896 ld e,(hl)       ; {#REGde=address of the desired sprite
 $6897 inc hl          ;
 $6898 ld d,(hl)       ; }
 $6899 ld l,(ix+$01)   ; {Set #REGhl to Y,X coords of sprite
 $689c ld h,(ix+$02)   ; }
 $689f cp $06          ; Comparing with original frame count from 687e
 $68a1 jr nc,$68b7     ; If original frame >= 6 then animation has finished
 $68a3 cp $03          ;
 $68a5 jr nc,$68d2     ; If original frame >= 3 then half animated
 $68a7 call $7263      ; Erase animation sprite
 $68aa ld a,($5dce)    ; #REGa=random number
 $68ad and $07         ;
 $68af or $42          ;
 $68b1 ld (ix+$03),a   ; Update colour attribute to a random colour
 $68b4 jp $7197        ; Colourize the sprite
; After an explosion, we check if it was the player that died!
*$68b7 ld a,(ix+$06)   ; {Update anim object so "animating" = "direction"?
 $68ba ld (ix+$00),a   ; }
 $68bd call $72ef      ; Update Actor position direction
 $68c0 call $726d      ; Find and destroy actor
 $68c3 ld (ix+$00),$00 ; Reset "animating"
 $68c7 ld a,(ix+$06)   ; Animation object "direction"
 $68ca and $3f         ;
 $68cc cp $03          ;
 $68ce jp c,$60b7      ; Player was killed if < 3 (end of turn)
 $68d1 ret             ;
; Called when half the explosion has been animated.
*$68d2 call $71f2      ; Get sprite screen position
 $68d5 jp $7270        ; Erase a destroyed actor

; Explosion sprites lookup table.
;
; Sprite addresses are repeated because on first use they are animated using a
; pink colour, then animated again in black, so as to make them disappear.
@label=explosion_sprite_table
w$68d8 defw $7bfd    ; Small explosion
 $68da defw $7bca    ; Medium explosion
 $68dc defw $7b97    ; Large explosion
 $68de defw $7bfd    ; Small explosion
 $68e0 defw $7bca    ; Medium explosion
 $68e2 defw $7b97    ; Large explosion

; Frame rate limiter.
;
; Called at the beginning of each game loop. Setting a higher pause value will
; slow down aliens, and the speed at which fuel/collectibles fall.
@label=FrameRateLimiter
c$68e4 ld a,($5dd5)  ; #REGa=frame ticked?
 $68e7 and a         ;
 $68e8 ret nz        ; We have a new frame, so no pause
; Execute an end-of-frame pause for the correct game speed
 $68e9 ld hl,$00c0   ; {#REGhl=pause counter (192)
*$68ec dec hl        ;
 $68ed ld a,l        ;
 $68ee or h          ;
 $68ef jr nz,$68ec   ; }
 $68f1 ret           ;

; Copy the two sprites for an alien to the buffers.
;
; Used by the routine at #R$6094.
@label=AlienBufferInit
c$68f2 ld hl,$690e   ; #REGhl=alien sprite lookup table
 $68f5 ld a,($5df0)  ; Current player level
 $68f8 rlca          ;
 $68f9 rlca          ;
 $68fa and $1c       ;
 $68fc ld e,a        ; {#REGde=offset address for lookup table
 $68fd ld d,$00      ; }
 $68ff add hl,de     ; Add offset
 $6900 push hl       ;
 $6901 ld de,$5e00   ; #REGde=right facing alien sprite buffer
 $6904 call $6eef    ; Reset rocket and copy sprite to buffer
 $6907 pop hl        ;
 $6908 ld de,$5e66   ; #REGde=left facing alien sprite buffer
; Set rocket building state on Jetman, then copy sprites to the first pair of
; buffers.
 $690b jp $6f16      ; Jetman rocket state update

; Alien sprite lookup table.
;
; Aliens have three basic movement types:
;
; * Single path: die upon impact with platforms.
; - Meteor
; - Jet Fighter
; - Space Craft
; * Variable path: direction changes randomly, or on platform collision.
; - Squidgy Alien
; - Sphere Alien
; - Crossed Ship
; * Chasers: move toward Jetman, avoid platform impacts.
; - UFO
; - Frog Alien
@label=alien_sprite_table
w$690e defw $7b69    ; Level #1: Meteor        (frame 1)
 $6910 defw $7b80    ; -                     - (frame 2)
 $6912 defw $7e66    ; Level #2: Squidgy Alien (frame 1)
 $6914 defw $7e83    ; -                     - (frame 2)
 $6916 defw $7ec0    ; Level #3: Sphere Alien  (frame 1)
 $6918 defw $7ee1    ; -                     - (frame 2)
 $691a defw $7ea0    ; Level #4: Jet Fighter
 $691c defw $7ea0
 $691e defw $7eaf    ; Level #5: UFO
 $6920 defw $7eaf
 $6922 defw $7efe    ; Level #6: Crossed Space Ship
 $6924 defw $7efe
 $6926 defw $7f1d    ; Level #7: Spacecraft
 $6928 defw $7f1d
 $692a defw $7f3a    ; Level #8: Frog Alien
 $692c defw $7f3a

; Frame update and disabled item drop.
;
; This also performs the self-modifying code update.
@label=FrameUpdate
c$692e di            ; This routine only called if EI, so we must now disable
 $692f ld a,($5c78)  ; {Update last_frame to current SYSVAR_FRAMES
 $6932 ld ($5dd4),a  ; }
 $6935 ld a,$01      ; {Frame has ticked over, set to true
 $6937 ld ($5dd5),a  ; }
 $693a push ix       ; Backup main jump table address
; Do some the code modifying...
 $693c ld hl,$5d30   ; #REGhl=points to the rocket object
@ssub=ld ($6971+$0d),hl ; Modify `LD BC, nnnn` - rocket object
 $693f ld ($697e),hl ;
 $6942 ld a,$c3      ; Value is a `JP` opcode
@ssub=ld ($6971+$2b),a  ; Modify instruction to be `JP`
 $6944 ld ($699c),a  ;
@nowarn
 $6947 ld hl,$6966   ; #REGhl=address to be modified
@ssub=ld ($6971+$2c),hl ; Modify `JP nnnn` address
 $694a ld ($699d),hl ;
; ...code modifying complete.
 $694d ld ix,$5d00   ; #REGix=Jetman object
 $6951 jp $631c      ; Execute main loop

; New actor: reset the modified code to original values.
;
; Used by the routines at #R$62fe and #R$6966.
@label=ResetModifiedCode
c$6954 ld hl,$5d88   ; #REGhl=inactive Jetman object
@ssub=ld ($6971+$0d),hl ; Reset `LD BC, 5D30` to use #REGhl
 $6957 ld ($697e),hl ;
 $695a ld a,$3a      ; Value is a `LD A (nnnn)` opcode
@ssub=ld ($6971+$2b),a  ; Restore modified opcode to `LD A (nnnn)` instruction.
 $695c ld ($699c),a  ;
 $695f ld hl,$0244   ;
@ssub=ld ($6971+$2c),hl ; Restore to `LD A (nnnn)` address to 0244
 $6962 ld ($699d),hl ;
 $6965 ret           ;

; Reset the modified code within the current frame.
;
; Used by the routine at #R$6971, but only after that routine's code has been
; modified by #R$692e.
@label=ResetModifiedInFrame
c$6966 call $6954    ; First, reset the self-modifying code
 $6969 pop ix        ; Restore jump table address, saved during frame update
 $696b xor a         ; {frame ticked=false - not a new frame
 $696c ld ($5dd5),a  ; }
 $696f ei            ; {Needed to tick over SYSVAR_FRAMES, main loop will
 $6970 ret           ; disable interrupts with the frame update call}

; Generate new game actor: alien, fuel, or collectible item.
;
; Depending on the self-modifying code state, this routine either generates a
; new item/alien, or updates the item drop game timer.
;
; Input:IX Item object.
@label=NewActor
c$6971 ld hl,$5dce   ; {Increment random number
 $6974 inc (hl)      ; }
 $6975 ld de,$0008   ; Set offset
 $6978 add ix,de     ; Set IX to next group of bytes
 $697a push ix       ; {Copy IX to HL
 $697c pop hl        ; }
; The self-modifying code routines change the address here to be either the
; inactive player (5d88) or the rocket object (5d30).
 $697d ld bc,$5d88   ; #REGbc=inactive player or rocket object
 $6980 and a         ; Clear the Carry flag
 $6981 sbc hl,bc     ; {If object pointed to by #REGix is before #REGbc object,
 $6983 jp c,$631c    ; then jump back to the main loop}
; Read the keyboard to introduce a slight pause?
*$6986 ld a,$fe      ; Row: Shift,Z,X,C,V
 $6988 out ($fd),a   ; Set port for reading keyboard
 $698a in a,($fe)    ; ...and read that row of keys
 $698c bit 0,a       ; Check if SHIFT key pressed
 $698e jr z,$6986    ; Jump if pressed
; Now increment timer and get new random number.
 $6990 ld hl,($5dcc) ; {Increment the game timer
 $6993 inc hl        ;
 $6994 ld ($5dcc),hl ; }
 $6997 ld h,$00      ; Make sure #REGhl remains <= $00FF
 $6999 ld a,r        ; Get a RANDOM number?
 $699b ld c,a        ;
; The self-modifying code routine changes this to `JP 6966`. That routine
; resets the interrupts, before changing instruction here to `LD A,(0244)` - an
; address in the ROM which always returns $C1.
 $699c ld a,($5dce)  ; #REGa=$C1, from 0244, because 5DCE is never used!
 $699f add a,(hl)    ; #REGa=byte from address $0000 - $00FF
 $69a0 add a,c       ; Add #REGr to the number
 $69a1 ld ($5dce),a  ; Update random number
 $69a4 ex af,af'     ; {Jump if current alien number < 3
 $69a5 ld a,($5dcb)  ;
 $69a8 cp $03        ;
 $69aa jr c,$69b8    ;
 $69ac ex af,af'     ; }
 $69ad and $1f       ;
 $69af jr nz,$69d9   ; Drop fuel/collectible if RND is < 32
 $69b1 ld a,($5dcb)  ; {Drop fuel/collectible if current alien number >= 6
 $69b4 cp $06        ;
 $69b6 jr nc,$69d9   ; }
*$69b8 ld a,($5dd7)  ; {Drop fuel/collectible if begin play delay counter >
 $69bb and a         ; zero
 $69bc jr nz,$69d9   ; }
 $69be ld a,($5d00)  ; Get jetman direction
 $69c1 and $3f       ;
 $69c3 dec a         ;
 $69c4 jr z,$69c9    ; If direction is zero, then find unused alien slot
 $69c6 dec a         ;
 $69c7 jr nz,$69d9   ; Drop fuel/collectible if direction is still > zero
; Find first unused alien slot.
*$69c9 ld hl,$5d50   ; Alien state objects
 $69cc ld b,$06      ; Loop counter (6 aliens)
 $69ce ld de,$0008   ;
*$69d1 ld a,(hl)     ; {Generate new alien if the slot is unused
 $69d2 and a         ;
 $69d3 jp z,$69e2    ; }
 $69d6 add hl,de     ; else increment to the next alien object
 $69d7 djnz $69d1    ; ...and try again
; Drop either a fuel pod or collectible item.
*$69d9 call $65f9    ; New fuel pod item
 $69dc call $65a8    ; New collectible item
 $69df jp $6310      ; Run main loop after resetting SP and EI
; Generate new alien in the given state slot (#REGhl).
*$69e2 push hl       ; Push current alien to stack (will be copied to #REGix)
 $69e3 ex de,hl      ;
 $69e4 ld hl,$6d94   ; {Copy default alien state to current alien slot
 $69e7 ld bc,$0008   ;
 $69ea ldir          ; }
 $69ec pop ix        ; Restore #REGix to point to current item object
 $69ee ld a,($5dcc)  ; Game timer
 $69f1 ld e,a        ; Backup to #REGe
 $69f2 and $40       ; #REGa=either 0 or 64
 $69f4 ld (ix+$04),a ; Set item "direction"
 $69f7 ld (ix+$00),a ; Set item "movement"
 $69fa ld a,e        ; Restore #REGa to original game timer value
 $69fb and $7f       ;
 $69fd add a,$28     ;
 $69ff ld (ix+$02),a ; Update item Y position
 $6a02 push ix       ; {Copy current item object address to #REGbc
 $6a04 pop bc        ; }
; Calculate and update new colour attribute.
 $6a05 ld a,c        ; Example: if BC = 5D78, C = $78 = 01111000
 $6a06 rra           ; 00111100
 $6a07 rra           ; 00011110
 $6a08 rra           ; 00001111
 $6a09 and $03       ; 00000011 <- result of AND $03
 $6a0b inc a         ; 00000100
 $6a0c inc a         ; 00000101 = $05
 $6a0d ld (ix+$03),a ; Update colour with value: $02, $03, $04, or $05
 $6a10 and $01       ;
 $6a12 ld (ix+$06),a ; Update jump table offset to either 0 or 1
 $6a15 ld hl,$6a2d   ; #REGhl=item level object types
 $6a18 ld a,($5df0)  ; {Using the current player level, pull a value from the
 $6a1b and $07       ; item level params table
 $6a1d ld e,a        ;
 $6a1e ld d,$00      ;
 $6a20 add hl,de     ;
 $6a21 ld a,(ix+$00) ;
 $6a24 and $c0       ;
 $6a26 or (hl)       ; }
 $6a27 ld (ix+$00),a ; Update item type to this value
 $6a2a jp $69d9      ; Drop fuel/collectible then execute the main loop

; New item object types for each level - 8 bytes for 8 levels.
@label=item_level_object_types
b$6a2d defb $03,$11,$06,$07,$0f,$05,$03,$0f

; Update Squidgy Alien.
;
; .
;
; Input:IX Alien object.
@label=SquidgyAlienUpdate
c$6a35 ld hl,$5dcb    ; {Increment current alien number
 $6a38 inc (hl)       ; }
 $6a39 call $6cb0     ; Update actor direction
 $6a3c call $6e1b     ; Fire laser beam (returns #REGc)
 $6a3f dec c          ;
 $6a40 jp z,$6aaf     ; Add the points for a kill if alien is dead
 $6a43 call $6de9     ; Alien collision check (returns #REGe)
 $6a46 dec e          ;
 $6a47 jp z,$6456     ; Alien killed by collision if #REGe is zero
 $6a4a xor a          ;
 $6a4b ld ($5dc9),a   ; Reset alien new direction flag
; Check which direction alien is travelling after hitting a platform.
*$6a4e call $75e8     ; Platform collision (returns #REGe)
 $6a51 bit 2,e        ; {Update alien X position if bit-2 is reset
 $6a53 jr z,$6a6a     ; }
 $6a55 bit 7,e        ; {Set alien direction to up if bit-7 set
 $6a57 jr nz,$6a93    ; }
 $6a59 bit 4,e        ; {Set alien direction to down if bit-4 set
 $6a5b jr nz,$6a99    ; }
; Alien has hit the end of a platform: change direction.
 $6a5d ld a,e         ; {Update alien "moving" value
 $6a5e and $40        ;
 $6a60 ld e,a         ;
 $6a61 ld a,(ix+$04)  ;
 $6a64 and $bf        ;
 $6a66 or e           ;
 $6a67 ld (ix+$04),a  ; }
; Update the alien X position.
*$6a6a bit 6,(ix+$04) ; Check alien moving left/right bit
 $6a6e ld a,(ix+$01)  ; #REGa=alien X position (fetch before the jump)
 $6a71 jr z,$6a9f     ; If moving left, subtract 2 from direction (via jump)
 $6a73 add a,$02      ; otherwise, we add 2 to move right
*$6a75 ld (ix+$01),a  ; Set new X position +/- 2
; Update the alien Y position, first checking if within the upper/lower bounds
; of the screen.
 $6a78 bit 7,(ix+$04) ; Check alien moving up/down bit
 $6a7c ld a,(ix+$02)  ; #REGa=alien Y position (fetch before the jump)
 $6a7f jr z,$6aa3     ; If moving up, subtract 2 from direction (via jump)
 $6a81 add a,$02      ; otherwise, we add 2 to move down
*$6a83 ld (ix+$02),a  ; Set new alien Y position +/- 2
; Draw the alien if new direction is set, otherwise repeat collision check
; again.
 $6a86 ld a,($5dc9)   ; {Draw the alien if the new direction flag is set,
 $6a89 and a          ; otherwise, increment the value
 $6a8a jp nz,$6d43    ;
 $6a8d inc a          ;
 $6a8e ld ($5dc9),a   ; }
 $6a91 jr $6a4e       ; Jump back and repeat collision check
; Change alien moving direction to up.
*$6a93 res 7,(ix+$04) ;
 $6a97 jr $6a6a       ;
; Change alien moving direction to down.
*$6a99 set 7,(ix+$04) ;
 $6a9d jr $6a6a       ;
; Subtract 2 from the X position (move left).
*$6a9f sub $02        ;
 $6aa1 jr $6a75       ;
; Subtract 2 from the Y position (move up), unless it has reached top of
; screen.
*$6aa3 sub $02        ;
 $6aa5 cp $24         ;
 $6aa7 jr nc,$6a83    ; Return if not at top of screen
 $6aa9 set 7,(ix+$04) ; Otherwise, set alien to moving down.
 $6aad jr $6a83       ;
; Add score to player if alien is dead.
*$6aaf ld bc,$0080    ; 80 points (decimal value)
 $6ab2 call $70c2     ; Add points to score
 $6ab5 jp $6bf1       ; Kill Alien SFX #1

; Update UFO alien -- this alien is a chaser!
;
; TODO: annotations are really messy/wrong here, needs lots more work to
; understand how the movement is calculated.
;
; Input:IX Alien object.
@label=UFOUpdate
c$6ab8 ld hl,$5dcb    ; {Increment current alien number
 $6abb inc (hl)       ; }
 $6abc call $6cb0     ; Update actor direction
 $6abf call $6e1b     ; Fire laser beam (returns #REGc)
 $6ac2 dec c          ;
 $6ac3 jp z,$6beb     ; Add the points for a kill if alien is dead
 $6ac6 call $6de9     ; Alien collision check (returns #REGe)
 $6ac9 dec e          ;
 $6aca jp z,$6456     ; Alien killed by collision if #REGe is zero
 $6acd xor a          ;
 $6ace ld ($5dc9),a   ; Reset alien new direction flag
; Check which direction alien is travelling after hitting a platform.
*$6ad1 call $75e8     ; Platform collision (returns #REGe)
 $6ad4 bit 2,e        ; {Update alien X position if bit-2 is reset
 $6ad6 jr z,$6af1     ; }
 $6ad8 bit 7,e        ; {Set alien direction to up if bit-7 set
 $6ada jp nz,$6bcd    ; }
 $6add bit 4,e        ; {Set alien direction to down if bit-4 set
 $6adf jp nz,$6bd4    ; }
; Move the flying saucer in a slightly more erratic way (the XOR), rather than
; just heading directly for the Jetman.
 $6ae2 ld a,e         ; {Update alien "moving" value
 $6ae3 and $40        ;
 $6ae5 xor $40        ;
 $6ae7 ld e,a         ;
 $6ae8 ld a,(ix+$04)  ;
 $6aeb and $bf        ;
 $6aed or e           ;
 $6aee ld (ix+$04),a  ; }
; Calculate new horizontal position and speed.
*$6af1 ld a,(ix+$05)  ; Alien X speed
 $6af4 ld b,a         ; {Calculate new speed?
 $6af5 and $0f        ;
 $6af7 ld c,a         ;
 $6af8 ld a,b         ;
 $6af9 and $f0        ;
 $6afb ld b,a         ; }
 $6afc ld a,($5d01)   ; Jetman X position
 $6aff sub (ix+$01)   ; Subtract alien X position
 $6b02 jp p,$6b74     ; If Jetman X > alien X, then jump
 $6b05 bit 6,(ix+$04) ; {If alien is moving left, then jump
 $6b09 jp z,$6b96     ; }
 $6b0c ld a,c         ; {If current speed is less than max, then increment
 $6b0d cp $0f         ;
 $6b0f jr nc,$6b12    ;
 $6b11 inc a          ; }
; Calculate new X position.
*$6b12 ld c,a         ; #REGc=current speed
 $6b13 ld h,(ix+$01)  ; #REGh=X position
 $6b16 call $6bdb     ; Calculates and returns #REGde, new position offset
 $6b19 and a          ; Clear the carry flag
 $6b1a sbc hl,de      ;
; Update the X position and speed
*$6b1c ld (ix+$01),h  ; Update X position
 $6b1f ld a,l         ; {Calculate and update X speed
 $6b20 and $f0        ;
 $6b22 or c           ;
 $6b23 ld (ix+$05),a  ; }
; Calculate new Y position and speed.
 $6b26 ld a,(ix+$06)  ; Alien Y speed
 $6b29 ld b,a         ;
 $6b2a and $0f        ;
 $6b2c ld c,a         ;
 $6b2d ld a,b         ;
 $6b2e and $f0        ;
 $6b30 ld b,a         ;
 $6b31 ld a,($5d02)   ; Jetman Y position
 $6b34 sub (ix+$02)   ; Subtract alien Y position
 $6b37 jp p,$6ba2     ; If Jetman Y > alien Y, then jump
 $6b3a bit 7,(ix+$04) ; {If alien is moving up then increment Y position (if
 $6b3e jp z,$6bc3     ; not at top of screen) and jump to 6b49}
 $6b41 ld a,c         ; {Calculate new down Y position if #REGc > 0 (presumably
 $6b42 dec a          ; above the ground)
 $6b43 jr nz,$6bae    ; }
 $6b45 res 7,(ix+$04) ; else moving direction must be set to up...
*$6b49 ld c,a         ; ..and #REGc will have been decremented here
 $6b4a ld h,(ix+$02)  ; #REGh=Y position
 $6b4d call $6bdb     ; Calculates and returns #REGde, new position offset
 $6b50 and a          ; Clear the carry flag
 $6b51 sbc hl,de      ;
*$6b53 ld a,h         ; {Set moving direction as down if at top of screen
 $6b54 cp $28         ;
 $6b56 jr nc,$6b5c    ;
 $6b58 set 7,(ix+$04) ; }
*$6b5c ld (ix+$02),a  ; Update Y position
 $6b5f ld a,l         ; {Update Y speed
 $6b60 and $f0        ;
 $6b62 or c           ;
 $6b63 ld (ix+$06),a  ; }
; Draw the alien if a new direction is set, otherwise repeat platform collision
; check again.
 $6b66 ld a,($5dc9)   ; Draw the alien if the new direction flag is set,
 $6b69 and a          ; otherwise, increment it
 $6b6a jp nz,$6d43    ;
 $6b6d inc a          ;
 $6b6e ld ($5dc9),a   ; }
 $6b71 jp $6ad1       ; Jump back and repeat collision check
; Check moving direction and update.
*$6b74 bit 6,(ix+$04) ; Check moving left/right bit
 $6b78 jr z,$6b8e     ; If moving left, increment speed (via jump)
 $6b7a ld a,c         ;
 $6b7b dec a          ;
 $6b7c jp nz,$6b12    ; If not zero, calculate X direction/speed
 $6b7f res 6,(ix+$04) ; else set X moving to "right"
*$6b83 ld c,a         ; #REGa (speed) was decremented from 0, so will now be FF
 $6b84 ld h,(ix+$01)  ; #REGh=X position
 $6b87 call $6bdb     ; Calculates and returns #REGde, new position offset
 $6b8a add hl,de      ;
 $6b8b jp $6b1c       ; Update the X position and speed
*$6b8e ld a,c         ; {If current speed is less than max, then increment
 $6b8f cp $0f         ;
 $6b91 jr nc,$6b83    ;
 $6b93 inc a          ; }
 $6b94 jr $6b83       ; Update position
*$6b96 ld a,c         ; #REGa=speed
 $6b97 dec a          ;
 $6b98 jp nz,$6b83    ; Update X position and speed unless zero
 $6b9b set 6,(ix+$04) ; Set moving direction to "right"
 $6b9f jp $6b12       ; Update X direction/speed
*$6ba2 bit 7,(ix+$04) ; Check Jetman moving direction
 $6ba6 jr z,$6bb9     ; Jump if top bit not set
 $6ba8 ld a,c         ; {Jump if #REGc >= 15
 $6ba9 cp $0f         ;
 $6bab jr nc,$6bae    ; }
 $6bad inc a          ; else increment it
*$6bae ld c,a         ; (will be #REGc = #REGc - 1)
 $6baf ld h,(ix+$02)  ;
 $6bb2 call $6bdb     ; Calculates and returns #REGde, new position offset
 $6bb5 add hl,de      ;
 $6bb6 jp $6b53       ; Update Y position and speed
*$6bb9 ld a,c         ; #REGa=speed
 $6bba dec a          ;
 $6bbb jr nz,$6b49    ; If speed > 0 move upwards
 $6bbd set 7,(ix+$04) ; else set moving direction to "down"
 $6bc1 jr $6bae       ; ...and update Y position and speed
*$6bc3 ld a,c         ; {If current speed is less than max, then increment it,
 $6bc4 cp $0f         ; and update position
 $6bc6 jp nc,$6b49    ;
 $6bc9 inc a          ;
 $6bca jp $6b49       ; }
; Change alien moving direction to up.
*$6bcd res 7,(ix+$04) ;
 $6bd1 jp $6af1       ;
; Change alien moving direction to down.
*$6bd4 set 7,(ix+$04) ;
 $6bd8 jp $6af1       ;
; Returns #REGde (new position) as calculated from the speed (#REGc).
*$6bdb ld l,b         ;
 $6bdc ld a,c         ; #REGc should be <= 15. Example, if value is $0F:
 $6bdd rla            ; 0 00011110
 $6bde rla            ; 0 00111100
 $6bdf rla            ; 0 01111000
 $6be0 rla            ; 0 11110000
 $6be1 and $f0        ; Clear lower 4 bits...just in case!
 $6be3 ld e,a         ;
 $6be4 ld d,$00       ;
 $6be6 sla e          ; 1 11100000
 $6be8 rl d           ; If E >= 8, then bit-0 of D is set
 $6bea ret            ;

; Add points for UFO kill.
;
; Used by the routine at #R$6ab8.
@label=UFOKillAddPoints
c$6beb ld bc,$0050   ; 50 points (decimal value)
 $6bee call $70c2    ; Add points to score

; Alien Killed SFX #1 - no score added.

; When alien was killed by laser fire, reset anim state, set explosion SFX
; params. Used by the routine at #R$6a35.
;
; Used by the routine at #R$6a35.
@label=AlienKillAnimSfx1
c$6bf1 call $685d    ; Update actor state
 $6bf4 xor a         ; #REGa should be 0 for the Alien SFX
 $6bf5 jp $67fd      ; Plays explosion SFX for an Alien

; Update Sphere alien.
;
; .
;
; Input:IX Alien object.
@label=SphereAlienUpdate
c$6bf8 ld hl,$5dcb    ; {Increment current alien number
 $6bfb inc (hl)       ; }
 $6bfc call $6cb0     ; Update actor direction
 $6bff xor a          ;
 $6c00 ld ($5dc9),a   ; Reset alien new direction flag
 $6c03 call $6e1b     ; Fire laser beam (returns #REGc)
 $6c06 dec c          ;
 $6c07 ld bc,$0040    ; 40 points (decimal value)
 $6c0a jp z,$6d5c     ; Kill Alien SFX #2 if alien is dead
 $6c0d call $6de9     ; Alien collision check (returns #REGe)
 $6c10 dec e          ;
 $6c11 jp z,$6456     ; Alien killed by collision if #REGe is zero
; Check which direction alien is travelling after hitting a platform.
*$6c14 call $75e8     ; Platform collision (returns #REGe)
 $6c17 bit 2,e        ; {Update alien Y position if bit-2 is reset
 $6c19 jr z,$6c30     ; }
 $6c1b bit 7,e        ; {Set alien direction to up if bit-7 set
 $6c1d jr nz,$6c94    ; }
 $6c1f bit 4,e        ; {Set alien direction to down if bit-4 set
 $6c21 jr nz,$6c9a    ; }
; Alien has hit the end of a platform: change direction.
 $6c23 ld a,e         ; {Update alien "moving" value
 $6c24 and $40        ;
 $6c26 ld e,a         ;
 $6c27 ld a,(ix+$04)  ;
 $6c2a and $bf        ;
 $6c2c or e           ;
 $6c2d ld (ix+$04),a  ; }
; Update the alien Vertical position.
*$6c30 bit 0,(ix+$04) ; Check alien moving direction
 $6c34 jr nz,$6c5b    ; Update Y position if vertical movement
 $6c36 ld a,($5dce)   ; {#REGe=random number
 $6c39 ld e,a         ; }
 $6c3a and $0f        ;
 $6c3c jr nz,$6c5b    ; Jump if != 0
 $6c3e set 0,(ix+$04) ; else set "moving" bit-0
 $6c42 ld a,($5dcc)   ; {Use Game timer to Y speed
 $6c45 and $1f        ;
 $6c47 add a,$10      ;
 $6c49 ld (ix+$06),a  ; }
 $6c4c ld a,e         ; #REGa=original random number
 $6c4d and $80        ;
 $6c4f ld e,a         ; #REGe = 0 or 128
 $6c50 ld a,(ix+$04)  ; {Update alien "moving" to either 127 or 255
 $6c53 and $7f        ;
 $6c55 or e           ;
 $6c56 ld (ix+$04),a  ; }
 $6c59 jr $6c14       ; Jump back and repeat collision check
; Update the alien Horizontal position.
*$6c5b bit 0,(ix+$04) ; Check alien "moving"
 $6c5f jr z,$6c78     ; Update X position if horizontal movement
 $6c61 ld a,(ix+$02)  ; else update Y position
; Update the alien Y position, first checking if within the upper/lower bounds
; of the screen.
 $6c64 bit 7,(ix+$04) ; Check moving up/down bit
 $6c68 jr z,$6ca0     ; If moving up, subtract 2 from direction (via jump)
 $6c6a add a,$02      ; otherwise, we add 2 to move down
*$6c6c ld (ix+$02),a  ; Set new Y position +/- 2
 $6c6f dec (ix+$06)   ; Decrement Y speed
 $6c72 jr nz,$6c78    ;
 $6c74 res 0,(ix+$04) ; Reset bit-0 of alien "moving" if speed is zero
; Update the alien X position.
*$6c78 ld a,(ix+$01)  ; #REGa=X position (fetch before the jump)
 $6c7b bit 6,(ix+$04) ; Check moving left/right bit
 $6c7f jr z,$6cac     ; If moving left, subtract 2 from direction (via jump)
 $6c81 add a,$02      ; otherwise, we add 2 to move right
*$6c83 ld (ix+$01),a  ; Set new X position +/- 2
; Draw the alien if a new direction is set, otherwise repeat platform collision
; check again.
 $6c86 ld a,($5dc9)   ; {Draw the alien if the new direction flag is set,
 $6c89 and a          ; otherwise, increment the value
 $6c8a jp nz,$6d43    ;
 $6c8d inc a          ;
 $6c8e ld ($5dc9),a   ; }
 $6c91 jp $6c14       ; Jump back and repeat collision check
; Change alien moving direction to up.
*$6c94 res 7,(ix+$04) ;
 $6c98 jr $6c30       ;
; Change alien moving direction to down.
*$6c9a set 7,(ix+$04) ;
 $6c9e jr $6c30       ;
; Subtract 2 from the Y position (move up), unless it has reached top of
; screen.
*$6ca0 sub $02        ;
 $6ca2 cp $28         ;
 $6ca4 jr nc,$6c6c    ; Return if not at top of screen
 $6ca6 set 7,(ix+$04) ; Otherwise, set to moving down
 $6caa jr $6c6c       ;
; Subtract 2 from horizontal direction.
*$6cac sub $02        ;
 $6cae jr $6c83       ;

; Update Actor direction.
;
; Used by the routines at #R$63a3, #R$6a35, #R$6ab8, #R$6bf8 and #R$6cbe.
;
; Input:IX Actor object.
@label=ActorUpdateDir
c$6cb0 call $72ef    ; Update Actor position direction
 $6cb3 ld a,(ix+$00) ; Actor direction
 $6cb6 and $c0       ;
 $6cb8 or $03        ;
@ssub=ld ($5dc0+$02),a ; Update actor "direction"
 $6cba ld ($5dc2),a  ;
 $6cbd ret           ;

; Update crossed space ship.
;
; .
;
; Input:IX Alien object.
@label=CrossedShipUpdate
c$6cbe call $6cb0      ; Update actor direction
 $6cc1 ld hl,$5dcb     ; {Increment alien number
 $6cc4 inc (hl)        ; }
 $6cc5 call $6e1b      ; Fire laser beam (returns #REGc)
 $6cc8 dec c           ;
 $6cc9 jp z,$6d59      ; Add points and kill alien (type #3) if dead
 $6ccc call $6de9      ; Alien collision (returns #REGe)
 $6ccf dec e           ;
 $6cd0 jp z,$6456      ; Alien killed by collision
 $6cd3 xor a           ;
 $6cd4 ld ($5dc9),a    ; Reset alien new direction
; Crossed ship direction change on platform collision.
@label=CrossedShipPlatformCollision
*$6cd7 call $75e8      ; Platform collision (returns #REGe)
 $6cda bit 2,e         ; {Update alien X position if bit-2 is reset
 $6cdc jr z,$6cf7      ; }
 $6cde bit 7,e         ; {Set alien direction to up if bit-7 set
 $6ce0 jp nz,$6d67     ; }
 $6ce3 bit 4,e         ; {Set alien direction to down if bit-4 set
 $6ce5 jp nz,$6d76     ; }
; Alien has hit the end of a platform: change direction in a slightly more
; erratic way than other aliens (note the XOR).
 $6ce8 ld a,e          ; {Update alien "moving" value
 $6ce9 and $40         ;
 $6ceb xor $40         ;
 $6ced ld e,a          ;
 $6cee ld a,(ix+$04)   ;
 $6cf1 and $bf         ;
 $6cf3 or e            ;
 $6cf4 ld (ix+$04),a   ; }
; Move crossed ship horizontally.
@label=CrossedShipMoveShip
*$6cf7 bit 6,(ix+$04)  ; Check moving left/right bit
 $6cfb ld a,(ix+$01)   ; #REGa=X position (fetch before the jump)
 $6cfe jp nz,$6d7d     ; If moving left, subtract 2 from direction (via jump)
 $6d01 add a,$02       ; otherwise, we add 2 to move right
; Update the alien YX position.
*$6d03 ld (ix+$01),a   ; Set new X position +/- 2
 $6d06 ld h,$00        ; {#REGhl=Y speed x 2
 $6d08 ld l,(ix+$06)   ;
 $6d0b add hl,hl       ; }
 $6d0c ld d,(ix+$02)   ; #REGd=alien X position
 $6d0f ld e,(ix+$05)   ; #REGe=alien X speed
 $6d12 bit 7,(ix+$04)  ; {If alien moving is "up" subtract hl/de
 $6d16 jr z,$6d8d      ; }
 $6d18 add hl,de       ; else add them
; Update vertical position, direction, and speed.
*$6d19 ld (ix+$05),l   ; Set alien X speed
 $6d1c ld (ix+$02),h   ; Alien Y position = #REGh
 $6d1f ld a,h          ; {If alien is at top of screen, set to moving down
 $6d20 cp $28          ;
 $6d22 jr nc,$6d28     ;
 $6d24 set 7,(ix+$04)  ; }
*$6d28 bit 7,(ix+$04)  ; Check if moving up
 $6d2c jr z,$6d82      ; Change alien direction to down if it is
 $6d2e inc (ix+$06)    ; else increment Y speed
 $6d31 jr nz,$6d37     ; Jump if it wasn't $FF before the increment
 $6d33 ld (ix+$06),$ff ; else set Y speed to $FF
; Draw the alien if a new direction is set, otherwise repeat platform collision
; check again.
*$6d37 ld a,($5dc9)    ; {Draw the alien if the new direction flag is set,
 $6d3a and a           ; otherwise, increment the value
 $6d3b jr nz,$6d43     ;
 $6d3d inc a           ;
 $6d3e ld ($5dc9),a    ; }
 $6d41 jr $6cd7        ; Jump back and repeat collision check

; Draw an alien sprite to the screen.
;
; Used by the routines at #R$6a35, #R$6ab8, #R$6bf8 and #R$6cbe.
;
; Input:IX Alien object.
@label=DrawAlien
c$6d43 ld a,(ix+$00) ; {Backup alien direction
 $6d46 push af       ; }
 $6d47 and $c0       ; {Temporarily change alien direction
 $6d49 or $03        ;
 $6d4b ld (ix+$00),a ; }
 $6d4e call $7232    ; Update actor X position (using temp direction)
 $6d51 call $7197    ; Colourize the sprite
 $6d54 pop af        ;
 $6d55 ld (ix+$00),a ; Restore original direction
 $6d58 ret           ;

; Add score for crossed space ship kill.
;
; Used by the routine at #R$6cbe.
@label=CrossedShipKillPoints
c$6d59 ld bc,$0060   ; 60 points (decimal value)

; Alien Killed SFX #2.
;
; When alien was killed by laser fire, reset anim state, set explosion SFX
; params, and add score. Used by the routine at #R$6bf8.
@label=AlienKillAnimSfx2
c$6d5c call $70c2    ; Add points to score
 $6d5f call $685d    ; Update actor state
 $6d62 ld a,$01      ; Set SFX to type #2
 $6d64 jp $67fd      ; Play explosion sound with SFX type #2

; Change alien direction flag to up, and other updates.
;
; Used by the routine at #R$6cd7.
@label=CrossedShipDirUp
c$6d67 res 7,(ix+$04) ; Set alien to moving up
 $6d6b ld a,($5dce)   ; {Update Y speed using random number
 $6d6e add a,$08      ;
 $6d70 ld (ix+$06),a  ; }
 $6d73 jp $6cf7       ; Update alien position
; Change alien moving direction flag to down.
*$6d76 set 7,(ix+$04) ;
 $6d7a jp $6cf7       ; Update alien position
; Subtract 2 from X position.
*$6d7d sub $02        ;
 $6d7f jp $6d03       ; Update alien YX position
; Change direction to down.
@label=CrossedShipDirDown
*$6d82 dec (ix+$06)   ; Decrement Y speed
 $6d85 jr nz,$6d37    ; {If speed is zero, set to moving down
 $6d87 set 7,(ix+$04) ; }
 $6d8b jr $6d37       ; Draw alien and perform platform collision
; This entry point is used by the routine at #R$6cbe.
*$6d8d and a          ; Reset Carry flag
 $6d8e ex de,hl       ; Swap registers
 $6d8f sbc hl,de      ; Subtract #REGde and Carry flag from #REGhl
 $6d91 jp $6d19       ; Update vertical position, direction, and speed

; Default alien state.
;
; Copied to the alien object when a new alien is instantiated.
@label=default_alien_state
b$6d94 defb $03,$00,$00,$42,$80,$04,$00,$1c

; Update the meteor.
;
; .
;
; Input:IX Alien object.
@label=MeteorUpdate
c$6d9c call $72ef     ; Update Actor position direction
 $6d9f ld hl,$5dcb    ; {Increment alien number
 $6da2 inc (hl)       ; }
; Update the alien X position.
 $6da3 ld a,(ix+$01)  ; #REGa=X position
 $6da6 bit 6,(ix+$04) ; Check moving left/right bit
 $6daa jr nz,$6de4    ; If moving left, subtract 2 from direction (via jump)
 $6dac add a,(ix+$05) ; otherwise, we add alien X speed to value
*$6daf ld (ix+$01),a  ; Set new X position +/- 2
; Update the alien Y position.
 $6db2 ld a,(ix+$02)  ; {Add Y speed to current Y position
 $6db5 add a,(ix+$06) ;
 $6db8 ld (ix+$02),a  ; }
 $6dbb call $7232     ; Update actor X position (using temp direction)
 $6dbe call $7197     ; Colourize the sprite
 $6dc1 call $75e8     ; Platform collision (returns #REGe)
 $6dc4 bit 2,e        ; {Kill alien it collided with a platform
 $6dc6 jr nz,$6ddd    ; }
 $6dc8 call $6e1b     ; Fire laser beam (returns #REGc)
 $6dcb ld a,c         ; {Kill alien if it is dead
 $6dcc and a          ;
 $6dcd jr nz,$6dd7    ; }
 $6dcf call $6de9     ; Alien collision check (returns #REGe)
 $6dd2 dec e          ; {Alien killed by collision if #REGe is zero. Player
 $6dd3 jp z,$6456     ; gets no points!}
 $6dd6 ret            ;
; Add score for Meteor kill.
*$6dd7 ld bc,$0025    ; 25 points (decimal value)
 $6dda call $70c2     ; Add points to score
; Kill meteor - reset state, and play explosion SFX #1.
*$6ddd call $685d     ; Update actor state
 $6de0 xor a          ; #REGa should be 0 for the Alien SFX
 $6de1 jp $67fd       ; Plays explosion SFX for an Alien
; Subtract 2 from horizontal direction.
*$6de4 sub (ix+$05)   ; Subtract X speed
 $6de7 jr $6daf       ;

; Alien Collision.
;
; Used by the routines at #R$63a3, #R$6461, #R$64e8, #R$66d0, #R$6a35, #R$6ab8,
; #R$6bf8, #R$6cbe and #R$6d9c.
;
;  Input:IX Alien object.
; Output:E as either $00 or $01.
@label=AlienCollision
c$6de9 ld hl,$5d00   ; #REGhl=Jetman object
 $6dec ld e,$00      ; Default value for #REGe
 $6dee ld a,(hl)     ; Jetman direction
 $6def and $3f       ;
 $6df1 dec a         ; {Jump if #REGa - 1 == 0
 $6df2 jr z,$6df6    ; }
 $6df4 dec a         ;
 $6df5 ret nz        ; Return if #REGa is not zero
*$6df6 inc hl        ; #REGhl=Jetman X position
 $6df7 ld a,(hl)     ;
 $6df8 sub (ix+$01)  ; Jetman X position - Alien X position
 $6dfb jp p,$6e00    ; {Make sure we have a positive byte
 $6dfe neg           ; }
*$6e00 cp $0c        ; {Return if #REGa >= 12
 $6e02 ret nc        ; }
 $6e03 inc hl        ; #REGhl=Jetman Y position
 $6e04 ld a,(hl)     ;
 $6e05 sub (ix+$02)  ; Jetman Y position - Alien Y position
 $6e08 jp p,$6e14    ; Set #REGd to 15 if it's still a positive number
 $6e0b neg           ; else: negate it
 $6e0d ld d,(ix+$07) ; #REGd=alien sprite height
 $6e10 add a,$0e     ;
 $6e12 jr $6e16      ; Compare and return
*$6e14 ld d,$15      ; default #REGd to 21
*$6e16 cp d          ; {Return $00 if #REGd >= #REGa
 $6e17 ret nc        ; }
 $6e18 ld e,$01      ;
 $6e1a ret           ; else return $01

; Fire a laser beam.
;
; Used by the routines at #R$63a3, #R$6a35, #R$6ab8, #R$6bf8, #R$6cbe and
; #R$6d9c.
;
;  Input:IX Alien object.
; Output:C Is either $00 or $01.
;        HL Pointer to current active laser beam object.
@label=LaserBeamFire
c$6e1b ld de,$0008   ; offset
 $6e1e ld hl,$5d08   ; Laser beam objects
 $6e21 ld b,$04      ; Loop counter (4 laser beams)
*$6e23 push hl       ; #REGhl: += 8 after first iteration
 $6e24 ld a,(hl)     ; {If current laser beam is in use, try next one
 $6e25 and a         ;
 $6e26 jr z,$6e5f    ; }
 $6e28 inc hl        ; #REGhl=Y position
 $6e29 inc hl        ; #REGhl=X position: pulse #1
 $6e2a inc hl        ; #REGhl=X position: pulse #2
 $6e2b ld a,(hl)     ; #REGa=pulse #2
 $6e2c dec hl        ; #REGhl=X position: pulse #1
 $6e2d bit 2,a       ; {Next iteration is bit-2 of pulse #2 is reset
 $6e2f jr z,$6e5f    ; }
 $6e31 and $f8       ;
 $6e33 sub (ix+$01)  ; Subtract alien X position from laser beam X position
 $6e36 jp p,$6e3f    ; If positive number, check position and next iteration
 $6e39 neg           ;
 $6e3b ld c,$08      ;
 $6e3d jr $6e41      ;
*$6e3f ld c,$20      ;
*$6e41 cp c          ; {Next iteration if pulse X position is now >= 8/32
 $6e42 jr nc,$6e5f   ; }
 $6e44 dec hl        ; #REGhl=Y position
 $6e45 ld a,(hl)     ;
 $6e46 sub (ix+$02)  ; Subtract alien Y position from laser beam Y position
 $6e49 neg           ;
 $6e4b jp m,$6e5f    ; If subtraction was negative number, next iteration
 $6e4e add a,$0c     ; else, add 12
 $6e50 cp (ix+$07)   ; {Next iteration if >= sprite height
 $6e53 jp nc,$6e5f   ; }
 $6e56 ld c,$01      ; else set return value to $01
 $6e58 inc hl        ; {Update X position: pulse #1
 $6e59 ld a,(hl)     ;
 $6e5a and $f8       ;
 $6e5c ld (hl),a     ; }
 $6e5d pop hl        ; Set #REGhl to first byte of current group
 $6e5e ret           ; We're done here
*$6e5f pop hl        ; {Try next laser beam object
 $6e60 add hl,de     ;
 $6e61 djnz $6e23    ; }
 $6e63 ld c,$00      ; {Return $00
 $6e65 ret           ; }

; Reads 2 bytes of pixel data from a sprite.
;
; Used by the routine at #R$6ea5.
;
;  Input:B Loop counter - sprite height?
;        HL Address of byte for current sprite.
; Output:B Same value as on entry.
;        D First byte of pixel data.
;        E ????
;        C Second byte of pixel data.
;        HL Address to the next byte of the sprite.
@label=SpriteReadTwoBytes
c$6e66 ld a,b        ; {Backup #REGb value
 $6e67 ex af,af'     ; }
 $6e68 ld e,$00      ; #REGe=third byte - NULL on read
 $6e6a ld c,(hl)     ; #REGc=first pixel byte
 $6e6b inc hl        ;
 $6e6c ld d,(hl)     ; #REGd=second pixel byte
 $6e6d inc hl        ; Set #REGhl to next byte (used later)
 $6e6e ld a,b        ; {Return if #REGb == 0
 $6e6f and a         ;
 $6e70 ret z         ; }
; Rotating the bits.
*$6e71 srl c         ; {Executes #REGb times
 $6e73 rr d          ;
 $6e75 rr e          ;
 $6e77 djnz $6e71    ; }
 $6e79 ex af,af'     ; {Restore #REGb to the entry value
 $6e7a ld b,a        ; }
 $6e7b ret           ;

; Reverse all bits in Accumulator.
;
; Two buffers are used for sprites facing the opposite direction so we need to
; flip the bits such that %00100111 becomes %11100100.
@label=ReverseAccBits
c$6e7c push bc       ; Backup #REGbc
 $6e7d ld b,$08      ; Counter of 8-bits
*$6e7f rrca          ; {Do the bit reversal
 $6e80 rl c          ;
 $6e82 djnz $6e7f    ; }
 $6e84 ld a,c        ; Set return value
 $6e85 pop bc        ; Restore #REGbc
 $6e86 ret           ;

; Flip byte pair of an alien sprite so it faces opposite direction.
;
; Used by the routine at #R$6ea5.
;
;  Input:B Loop counter.
;        HL Pointer to current byte of sprite.
; Output:B Same value as on entry.
;        DE The flipped byte pair.
;        HL Pointer to next byte of sprite.
@label=BufferFlipSprite
c$6e87 ld a,b        ; {Backup #REGb value
 $6e88 ex af,af'     ; }
 $6e89 ld c,$00      ;
 $6e8b ld a,(hl)     ; Get byte from sprite
 $6e8c call $6e7c    ; #REGa=reversed byte
 $6e8f ld e,a        ;
 $6e90 inc hl        ; {Get next byte from sprite
 $6e91 ld a,(hl)     ; }
 $6e92 call $6e7c    ; #REGa=reversed byte
 $6e95 ld d,a        ;
 $6e96 inc hl        ; Point #REGhl to next byte
 $6e97 ld a,b        ; {Return if all bytes have been processed
 $6e98 and a         ;
 $6e99 ret z         ; }
*$6e9a sla e         ; {Shift sprite 4-pixels to the right?
 $6e9c rl d          ;
 $6e9e rl c          ;
 $6ea0 djnz $6e9a    ; }
 $6ea2 ex af,af'     ; {Restore #REGb to the original value
 $6ea3 ld b,a        ; }
 $6ea4 ret           ;

; Write all sprite pixel bytes to buffer.
;
; Bytes are first shifted and/or flipped along the horizontal axis. Used by the
; routine at #R$6f2a.
;
; Input:B Loop counter - sprite height.
;       HL Pointer to buffer for data to be written to.
@label=BufferWritePixel
c$6ea5 exx           ; #REGhl=sprite, #REGhl'=buffer, #REGb'=counter
 $6ea6 ld a,($5dd2)  ; {Get next two bytes if Jetman rocket module status is
 $6ea9 and a         ; zero
 $6eaa jr z,$6ebd    ; }
 $6eac call $6e87    ; #REGde=flipped byte pair
*$6eaf push de       ;
 $6eb0 push bc       ;
 $6eb1 exx           ; #REGhl=buffer, #REGb=counter
 $6eb2 pop de        ;
 $6eb3 ld (hl),e     ; Write first byte
 $6eb4 inc hl        ;
 $6eb5 pop de        ;
 $6eb6 ld (hl),d     ; Write the second byte
 $6eb7 inc hl        ;
 $6eb8 ld (hl),e     ; Write third byte
 $6eb9 inc hl        ; #REGhl=next buffer address
 $6eba djnz $6ea5    ; Loop back, writing reversed sprite data to buffer
 $6ebc ret           ; We're done.
*$6ebd call $6e66    ; #REGde=two new bytes of sprite pixel data
 $6ec0 jr $6eaf      ; Loop back, writing non-reversed sprite data to buffer

; Copy Rocket sprites for current level to the buffers.
;
; Using the sprite lookup table, this routine calculates which Rocket sprites
; to copy to the buffers or the current level, then calls the copy routine.
; Used by the routines at #R$60a7, #R$60b7 and #R$6565.
;
; Input:A Is the byte offset between the modules of the current rocket.
@label=BufferCopyRocket
c$6ec2 ld c,a        ;
 $6ec3 ld a,($5df0)  ; #REGa=player level. Example, if level 3:
 $6ec6 rrca          ; A=10000001, C=1
 $6ec7 and $06       ; A=00000000
 $6ec9 or c          ; A=00001000 (e.g. if #REGc=$08)
 $6eca ld c,a        ; {#REGbc=sprite offset value
 $6ecb ld b,$00      ; }
 $6ecd ld hl,$678c   ; Collectible sprite lookup table
 $6ed0 add hl,bc     ; Offset address
 $6ed1 ld de,$5ecc   ; #REGde=start of buffers for all item sprites
 $6ed4 ld a,$02      ;
 $6ed6 ld ($5dd3),a  ; Set default for rocket module attached value
 $6ed9 xor a         ;
 $6eda ld ($5dd2),a  ; Set default for Jetman rocket module connected value
 $6edd ld c,$04      ; Loop counter - all 4 sprites?
 $6edf xor a         ;
*$6ee0 push bc       ; Backup loop counter
 $6ee1 ld b,a        ; #REGa starts at $00, then returns value from #R$6f0b
 $6ee2 ld c,$01      ; #REGc=sprite count
 $6ee4 call $6f0b    ; #REGhl=pointer to sprite pixel data
 $6ee7 ld a,b        ;
 $6ee8 pop bc        ; Restore loop counter
 $6ee9 dec hl        ; {#REGhl=previous lookup table offset
 $6eea dec hl        ; }
 $6eeb dec c         ; Decrement loop counter
 $6eec jr nz,$6ee0   ; Repeat until counter is zero
 $6eee ret           ;

; Initialise rocket build state for new level.
;
; After initialising, sprites are copied to the first pair of buffers. Used by
; the routine at #R$68f2.
;
; Output:A New Jetman module connect status.
@label=RocketBuildStateReset
c$6eef ld bc,$0002   ; #REGbc=sprite count
 $6ef2 ld a,$04      ; {Start of new level rocket state
 $6ef4 ld ($5dd3),a  ; }
 $6ef7 xor a         ; Used to reset Jetman module connect status
 $6ef8 jr $6f20      ;

; Old unused routines.
i$6efa

; Copy Rocket sprite pixel data to the buffer.
;
; Looks up the address for a sprite from the lookup table, then points #REGhl
; to the pixel data for that sprite. Used by the routine at #R$6ec2.
;
;  Input:HL Offset address in sprite lookup table.
;        DE Address of buffer to use.
; Output:HL Pointer to pixel data block.
@label=BufferCopyRocketSpriteData
c$6f0b push hl       ;
 $6f0c push de       ;
 $6f0d push bc       ;
 $6f0e ld a,(hl)     ; {#REGhl=sprite address, from lookup table
 $6f0f inc hl        ;
 $6f10 ld h,(hl)     ;
 $6f11 ld l,a        ; }
 $6f12 inc hl        ; #REGhl=sprite "height"
 $6f13 inc hl        ; #REGhl=sprite data block
 $6f14 jr $6f2a      ; Perform the copy

; Set the rocket building state on Jetman.
;
; After initialising the states, the sprites are then copied to the second pair
; of buffers. Used by the routine at #R$68f2.
@label=JetmanRocketStateUpdate
c$6f16 ld bc,$0002   ; #REGbc=sprite count
 $6f19 ld a,$04      ; Redundant opcode
 $6f1b ld a,($5dd3)  ; Redundant entry point for old code at 6F31
 $6f1e ld a,$01      ; Will set Jetman module connect status

; Set rocket module state that Jetman was carrying.
;
; Changed when Jetman successfully drops a carried module onto the Rocket pad.
; Used by the routine at #R$6eef.
;
; Input:A state value.
@label=SetDroppedModuleState
c$6f20 ld ($5dd2),a  ;

; Get address to sprite pixel data then copy to the buffer.
;
; Used by the routine at #R$6f2a.
;
;  Input:HL Offset address in sprite lookup table.
; Output:HL Pointer to pixel data block.
@label=BufferCopySprite
c$6f23 push hl       ;
 $6f24 push de       ;
 $6f25 push bc       ;
 $6f26 ld a,(hl)     ; {#REGhl=sprite address from lookup table
 $6f27 inc hl        ;
 $6f28 ld h,(hl)     ;
 $6f29 ld l,a        ; }

; Copies the sprite pixel data to a buffer.
;
; Note the copious amounts of register swapping! These annotations need
; checking. Used by the routine at #R$6f0b.
;
; Input:C Number of bytes to copy?
;       HL Address pointing to the "height" value in a sprite header
;       DE Address of buffer to use.
@label=BufferCopySpriteData
c$6f2a push hl       ;
 $6f2b ex de,hl      ; Swap Sprite<->Buffer addresses
 $6f2c exx           ;
 $6f2d pop hl        ; #REGhl=sprite address
 $6f2e pop bc        ; #REGc (sprite count) is the important value
 $6f2f push bc       ; Copy the counter back on the stack
 $6f30 ld a,(hl)     ; #REGa=sprite height value
 $6f31 ex af,af'     ; Backup "height" to #REGa'
 $6f32 inc hl        ; #REGhl=start of sprite pixel data
 $6f33 exx           ; #REGhl=buffer, #REGde=sprite
 $6f34 ld (hl),$00   ; Buffer: set first byte
 $6f36 inc hl        ;
 $6f37 ld (hl),$03   ; Buffer: set sprite width
 $6f39 inc hl        ; Point Buffer to height variable
 $6f3a ex af,af'     ; Restore #REGa with height value
 $6f3b cp $11        ; {Jump if height < 17 pixels
 $6f3d jr c,$6f41    ; }
 $6f3f ld a,$10      ; else height=16 pixels
*$6f41 ld (hl),a     ; Buffer: height will be <= 16
 $6f42 inc hl        ; Point Buffer to start of pixel data
 $6f43 ld b,a        ; #REGb=height variable
 $6f44 call $6ea5    ; Write pixel to a buffer
 $6f47 pop bc        ; Reset #REGbc to be only the sprite counter?
 $6f48 pop hl        ; #REGhl=start of buffer
 $6f49 ld de,$0033   ; {#REGhl=start of next buffer
 $6f4c add hl,de     ; }
 $6f4d pop de        ; #REGde=lookup table address
 $6f4e ex de,hl      ; #REGhl=sprite, #REGde=buffer
 $6f4f inc hl        ; #REGhl=sprite width value
 $6f50 inc hl        ; #REGhl=sprite height value
 $6f51 ld a,($5dd3)  ; #REGa=Rocket build state - only $00 or $04?
 $6f54 add a,b       ;
 $6f55 ld b,a        ;
 $6f56 dec c         ; Decrement the sprite counter
 $6f57 jr nz,$6f23   ; Fetch next sprite address
 $6f59 ret           ;

; Create new laser beam.
;
; Find an unused laser beam slot - return if non free - then initialise and
; draw the laser GFX in the correct location and direction in relation to
; Jetman. Used by the routine at #R$7492.
;
; Output:HL Address pointing to a free laser beam slot.
@label=LaserNewIfFreeSlot
c$6f5a ld a,($5c78)  ; {Return unless one of first two bits of SYSVAR_FRAMES
 $6f5d and $03       ; are set
 $6f5f ret nz        ; }
 $6f60 ld hl,$5d08   ; #REGhl=laser beam objects
 $6f63 ld de,$0008   ;
 $6f66 ld b,$04      ; Loop counter for all 4 laser beams
*$6f68 ld a,(hl)     ; Get first byte of object
 $6f69 and a         ;
 $6f6a jr z,$6f70    ; Initialise and draw laser beam, if unused
 $6f6c add hl,de     ;
 $6f6d djnz $6f68    ; Repeat until an unused beam is found
 $6f6f ret           ; Return if no free slots are available

; Initialise laser beam slot, and draw graphics.
;
; Used by the routine at #R$6f5a.
;
; Input:HL Address pointing to an unused laser beam.
@label=LaserBeamInit
c$6f70 ld (hl),$10   ; Set first byte to 16: "used"
 $6f72 inc hl        ; Laser Y position
 $6f73 ld de,$5d00   ; #REGde=Jetman object
 $6f76 ld a,(de)     ; {#REGb=direction in which to draw laser beam, based on
 $6f77 ld b,a        ; Jetman movement action}
 $6f78 inc de        ;
 $6f79 ld a,(de)     ; #REGa=Jetman X position
 $6f7a and $f8       ;
 $6f7c or $05        ;
 $6f7e ld c,a        ; #REGc=laser beam X position
 $6f7f bit 6,b       ; {Shoot laser right if Jetman is facing right
 $6f81 jr z,$6fb6    ; }
 $6f83 sub $08       ; else shoot laser beam left
 $6f85 ld c,a        ; #REGc=Jetman X position - 8

; Draw laser beam.
;
; Used by the routine at #R$6fb6.
;
; Input:C The X Position to start drawing the laser.
;       DE Jetman object (pointing to X position)
;       HL Laser beam object to be drawn (pointing to Y position)
@label=LaserBeamDraw
c$6f86 inc de        ; Jetman Y position
 $6f87 ld a,(de)     ; {Update the laser beam Y position to align with the
 $6f88 sub $0d       ; middle of the Jetman sprite
 $6f8a ld (hl),a     ; }
 $6f8b inc hl        ; Laser X position: pulse #1
 $6f8c ld b,$03      ; Loop counter
 $6f8e ld (hl),c     ; Update pulse #1
 $6f8f ld a,c        ;
 $6f90 and $fb       ;
*$6f92 inc hl        ; {Update the rest of the pulses: #2, #3 and #4
 $6f93 ld (hl),a     ;
 $6f94 djnz $6f92    ; }
 $6f96 inc hl        ; {Update the laser beam "length" value, using the
 $6f97 ld a,($5dce)  ; random_number as a base value
 $6f9a and $38       ;
 $6f9c or $84        ;
 $6f9e ld (hl),a     ; }
 $6f9f inc hl        ; {#REGde points to laser beam "colour attribute"
 $6fa0 ex de,hl      ; }
 $6fa1 ld hl,$6fb2   ; #REGhl=Laser beam colour table
 $6fa4 ld a,($5dce)  ; {Use random_number to point #REGhl to one of the values
 $6fa7 and $03       ; in the colour table
 $6fa9 ld c,a        ;
 $6faa ld b,$00      ;
 $6fac add hl,bc     ;
 $6fad ld a,(hl)     ; }
 $6fae ld (de),a     ; Assign laser beam "colour attribute" a new colour
 $6faf jp $67e7      ; Laser fire SFX

; Laser beam colour attribute table.
@label=laser_beam_colours
b$6fb2 defb $47,$43,$43,$45

; Shoots a laser beam to the right.
;
; Once position of Jetman's gun is located, we call the draw laser beam
; routine. Used by the routine at #R$6f70.
;
;  Input:C Jetman X position +/- a few pixels: 0-7 maybe?
;        DE Address of Jetman X position variable.
; Output:C New X position of laser beam.
@label=LaserBeamShootRight
c$6fb6 ld a,(de)     ; Jetman X position
 $6fb7 and $07       ; Checking for any laser beam pixels?
 $6fb9 ld a,c        ;
 $6fba jr z,$6fbe    ; {Increment X position if some laser pixels are set
 $6fbc add a,$08     ; }
*$6fbe add a,$10     ; {Add 16 and reset bit-0
 $6fc0 and $fe       ; }
 $6fc2 ld c,a        ; Set return value
 $6fc3 jr $6f86      ; Draw laser beam

; Animate a laser beam.
;
; Note the copious amounts of register swapping! These annotations need
; checking.
;
; Input:IX Laser beam object
@label=LaserBeamAnimate
c$6fc5 ld d,(ix+$01)   ; Laser Y position
 $6fc8 ld a,(ix+$02)   ; Laser X position: pulse #1
 $6fcb bit 2,a         ; {Jump if bit-2 is reset
 $6fcd jr z,$7007      ; }
 $6fcf ld l,a          ; #REGl=X position: pules #1
 $6fd0 ld a,$08        ;
 $6fd2 bit 0,l         ; {Negate (#REGa=$F8) if bit-0 of pulse #1 is reset
 $6fd4 jr z,$6fd8      ;
 $6fd6 neg             ; }
*$6fd8 add a,l         ; {#REGh=laser Y position, #REGl=updated X position
 $6fd9 ld e,a          ;
 $6fda ld h,d          ; }
 $6fdb push hl         ; Preserve #REGhl - pulse Y,X position
 $6fdc call $72d0      ; #REGhl=coord to screen address (using #REGhl)
 $6fdf ld a,(ix+$01)   ; Laser Y position
 $6fe2 cp $80          ; {Jump if Y position >= 128
 $6fe4 jr nc,$6fea     ; }
 $6fe6 ld a,(hl)       ; #REGa=byte at Y,X position of laser pulse #1
 $6fe7 and a           ;
 $6fe8 jr nz,$702c     ; Jump if byte is empty
; Update the on screen colour for the pulse.
*$6fea ld (ix+$02),e   ; Update X position: pulse #1
 $6fed ld (hl),$ff     ; Add a "full length" pulse to Y,X position
 $6fef pop hl          ; Restores the pulse Y,X positions
 $6ff0 call $71d6      ; #REGhl=coord to attribute file address (using #REGhl)
 $6ff3 ld a,(ix+$07)   ; {Set screen colour attribute to the laser pulse colour
 $6ff6 ld (hl),a       ; }
 $6ff7 ld a,(ix+$06)   ; {Subtract 8 from laser pulse "length"
 $6ffa sub $08         ;
 $6ffc ld (ix+$06),a   ; }
 $6fff and $f8         ;
 $7001 jr nz,$7007     ; Jump if pulse length has bit 3-7 set
; Update the X position of all the laser beam pulses.
*$7003 res 2,(ix+$02)  ; Reset bit-2 of X position: pulse #1
*$7007 exx             ;
 $7008 ld bc,$031c     ;
 $700b ld e,$e0        ; Loop counter (14)
 $700d exx             ;
 $700e ld e,$03        ; Loop counter (to process pulses #2, #3, #4)
 $7010 push ix         ; {#REGbc is now the laser beam object
 $7012 pop bc          ; }
 $7013 inc bc          ; Laser beam Y position
 $7014 inc bc          ; Laser beam X position: pulse #1
 $7015 inc bc          ; Laser beam X position: pulse #2
; A loop (to the end of routine) which draws the pixel byte to the screen.
*$7016 ld a,(bc)       ; #REGa=X position (loops on pulse #2, #3, #4)
 $7017 xor (ix+$02)    ; XOR with X position: pulse #1
 $701a and $f8         ;
 $701c jr nz,$702f     ; Jump if #REGa has any of these bits set
 $701e exx             ;
 $701f ld a,b          ;
 $7020 ld b,c          ;
 $7021 ld c,e          ;
 $7022 exx             ;
 $7023 inc bc          ; {Repeat for next X position pulse
 $7024 dec e           ;
 $7025 jr nz,$7016     ; }
 $7027 ld (ix+$00),$00 ; Set laser beam to "unused"
 $702b ret             ;
; No pixel to draw, loop back and process next pulse.
*$702c pop hl          ;
 $702d jr $7003        ;
; Update the length of the laser beam pulse.
*$702f ld a,(bc)       ; Laser beam X position
 $7030 bit 2,a         ; {Jump if bit-2 is set
 $7032 jr nz,$704f     ; }
 $7034 dec (ix+$06)    ; Decrement pulse length
 $7037 ld a,(ix+$06)   ;
 $703a and $07         ; {Return if pulse has any pixels set?
 $703c ret nz          ; }
 $703d ld a,($5dce)    ; Random number
 $7040 and $03         ; {Calculate the length of the laser pulse
 $7042 or $04          ;
 $7044 or (ix+$06)     ;
 $7047 ld (ix+$06),a   ; }
 $704a ld a,(bc)       ; {Current X position += 4
 $704b or $04          ;
 $704d ld (bc),a       ; }
 $704e ret             ;
*$704f ld a,(bc)       ;
 $7050 ld l,a          ; #REGl=current X position pulse
 $7051 ld a,$08        ;
 $7053 bit 0,l         ; {Negate (#REGa=$F8) if bit-0 of pulse is reset
 $7055 jr z,$7059      ;
 $7057 neg             ; }
*$7059 add a,l         ;
 $705a ld (bc),a       ; Update current X position
 $705b ld h,d          ; #REGh=laser Y position, #REGl=updated X position
 $705c call $72d0      ; #REGhl=coord to screen address (using #REGhl)
 $705f exx             ;
 $7060 ld a,b          ;
 $7061 ld b,c          ;
 $7062 ld c,e          ;
 $7063 exx             ;
; Create a new laser beam pixel and merge with current screen pixel.
 $7064 cpl             ; Create the pixel byte. E.g. $FC=11111100
 $7065 and (hl)        ; Merge with current screen pixel
 $7066 ld (hl),a       ; Update display file
 $7067 inc bc          ; {Next X position byte
 $7068 dec e           ; }
 $7069 jp nz,$7016     ; Repeat if counter > 0
 $706c ret             ;

; Display the remaining player lives in the status bar.
;
; Used by the routines at #R$6094, #R$6174 and #R$66d0.
@label=DisplayPlayerLives
c$706d ld hl,$0040   ; Screen column for Player 1
 $7070 call $72d0    ; #REGhl=coord to screen address (using #REGhl)
 $7073 call $70ac    ; #REGa=Get player 1 lives count
 $7076 and a         ;
 $7077 jr z,$7095    ; Display empty space if no lives remaining
 $7079 call $7088    ; Display lives counter and icon sprite
; Now display lives for inactive player.
*$707c ld hl,$00b0   ; Screen column for Player 2
 $707f call $72d0    ; #REGhl=coord to screen address (using #REGhl)
 $7082 call $70ba    ; #REGa=Get player 2 lives count
 $7085 and a         ;
 $7086 jr z,$709a    ; Display empty space if no lives remaining
; Displays the lives count and sprite icon.
*$7088 add a,$30     ; ASCII character starting at `0` character
 $708a call $7115    ; Display font character
 $708d ld de,$70a4   ; Sprite for the lives icon
 $7090 push bc       ;
 $7091 push de       ;
 $7092 jp $7124      ; Now display the number of lives
; Current player has no lives remaining, display spaces.
*$7095 call $709a    ; Display " " for no lives
 $7098 jr $707c      ; Display inactive player lives count
; Display just spaces instead of number + sprite.
*$709a ld a,$20      ;
 $709c call $7115    ; Display " " font character
 $709f ld a,$20      ;
 $70a1 jp $7115      ; Display " " font character

; Icon sprite of the little person shown next to number of lives.
@label=tile_life_icon
b$70a4 defb $18,$24,$3c,$7e,$5a,$3c,$3c,$66

; Gets the remaining lives for player 1.
;
; Used for displaying the player lives in the status bar.
;
; Output:A Is the number of lives remaining
@label=P1GetLifeCount
c$70ac ld a,($5dd1)  ; Current player number
 $70af and a         ;
 $70b0 jr nz,$70b6   ; If not current player, use inactive player

; Reads the current player lives.
;
; Used by the routine at #R$70ba.
@label=CurrentPlayerLifeCount
c$70b2 ld a,($5df1)  ; Current player lives remaining
 $70b5 ret           ;

; Reads inactive player lives.
;
; Used by the routines at #R$70ac and #R$70ba.
@label=InactivePlayerLifeCount
c$70b6 ld a,($5df9)  ; Inactive player lives remaining
 $70b9 ret           ;

; Gets the remaining lives for player 2.
;
; Used for displaying the player lives in the status bar.
;
; Output:A Is the number of lives remaining
@label=P2GetLifeCount
c$70ba ld a,($5dd1)  ; Current player number
 $70bd and a         ;
 $70be jr z,$70b6    ; If not current player, use inactive player
 $70c0 jr $70b2      ; else get current player lives

; Add points to the active player's score.
;
; Used by the routines at #R$63a3, #R$6461, #R$6523, #R$6a35, #R$6beb, #R$6d5c
; and #R$6d9c.
;
; Input:C The number of points (in decimal) to be added to the score.
@label=AddPointsToScore
c$70c2 ld a,($5dd1)  ; {Use player 2 score if current player is 2
 $70c5 and a         ;
 $70c6 jr nz,$70cd   ; }
@ssub=ld hl,$5cf4+$02 ; #REGhl=Player 1 score byte #3
 $70c8 ld hl,$5cf6   ;
 $70cb jr $70d0      ;
@ssub=ld hl,$5cf7+$02 ; #REGhl=Player 2 score byte #3
*$70cd ld hl,$5cf9   ;
; Add the points to the current score.
*$70d0 ld a,(hl)     ; {Update score byte #3, with BCD conversion
 $70d1 add a,c       ;
 $70d2 daa           ;
 $70d3 ld (hl),a     ; }
 $70d4 dec hl        ;
 $70d5 ld a,(hl)     ; {Update score byte #2, with BCD conversion
 $70d6 adc a,b       ;
 $70d7 daa           ;
 $70d8 ld (hl),a     ; }
 $70d9 dec hl        ;
 $70da ld a,(hl)     ; {Update score byte #1, with BCD conversion
 $70db adc a,$00     ;
 $70dd daa           ;
 $70de ld (hl),a     ; }
 $70df ld a,($5dd1)  ; {Jump and show player 2 score if current player is 2,
 $70e2 and a         ; else show player 1
 $70e3 jr nz,$70ed   ; }

; Updates display to show player 1 score.
;
; Used by the routine at #R$6064.
@label=ShowScoreP1
c$70e5 ld hl,$4021   ; Screen address for score text
 $70e8 ld de,$5cf4   ; 3-byte score value
 $70eb jr $70fb      ; Display a score

; Updates display to show player 2 score.
;
; Used by the routines at #R$6064 and #R$70c2.
@label=ShowScoreP2
c$70ed ld hl,$4039   ; Screen address for score text
 $70f0 ld de,$5cf7   ; 3-byte score value
 $70f3 jr $70fb      ; Display a score

; Updates display to show high score.
;
; Used by the routine at #R$6064.
@label=ShowScoreHI
c$70f5 ld hl,$402d   ; Screen address for score text
 $70f8 ld de,$5cf0   ; 3-byte hi score value

; Display a score.
;
; Scores are stored as decimal values in 3-bytes (making 999999 the maximum
; score). A score of 15,120 decimal is stored in hex as: $01,$51,$20. This
; routine displays each byte (reading left-to-right) of the score in two steps.
;
; Input:HL Screen address of the score to be written.
;       DE The 3-byte score value (P1, P2, HI).
@label=DisplayScore
c$70fb ld b,$03      ; Loop counter for the 3 bytes
*$70fd ld a,(de)     ; Score value. Example, if 85 points:
 $70fe rrca          ; A=11000010, C=1
 $70ff rrca          ; A=01100001, C=0
 $7100 rrca          ; A=10110000, C=1
 $7101 rrca          ; A=01011000, C=0
 $7102 and $0f       ; A=00001000
 $7104 add a,$30     ; A=00111000 - $30 + $08 = ASCII char `8`
 $7106 call $7115    ; Display font character
 $7109 ld a,(de)     ; And again with the same byte:
 $710a and $0f       ; A=00000101
 $710c add a,$30     ; A=00110101 - $30 + $05 = ASCII char `5`
 $710e call $7115    ; Display font character
 $7111 inc de        ; {Process next score byte
 $7112 djnz $70fd    ; }
 $7114 ret           ;

; Display an ASCII character from the Font.
;
; An ASCII 8x8 tile graphic is fetched from the font data and drawn to the
; screen. As HL is multiplied by 3 a 256 bytes offset must first be subtracted.
;
;  Input:A Character (Z80 ASCII) used to fetch the character from the font.
;        HL Screen address where character should be drawn.
; Output:HL Location for the next location character.
@label=DrawFontChar
c$7115 push bc       ;
 $7116 push de       ;
 $7117 push hl       ;
 $7118 ld l,a        ; #REGl=ASCII value
 $7119 ld h,$00      ;
 $711b add hl,hl     ; {Calculate correct offset for ASCII character
 $711c add hl,hl     ;
 $711d add hl,hl     ; }
@ssub=ld de,$9ab3-$0100 ; #REGde=base address of the font data - 256 bytes
 $711e ld de,$3a00   ;
 $7121 add hl,de     ; #REGhl += base address
 $7122 ex de,hl      ; Store the character address in #REGde
 $7123 pop hl        ; Restore #REGhl

; Characters are 8 rows of pixels.
;
; Used by the routine at #R$706d.
@label=DrawCharPixels8Rows
c$7124 ld b,$08      ; Loop counter

; Draw the pixels for an ASCII character on screen
;
; Used by the routine at #R$76a6.
;
;  Input:B Loop counter for no. of pixel rows - is always $08!
;        DE Address for desired character from the font set.
;        HL Display address for where to draw the character.
; Output:HL Next character location.
@label=DrawCharPixels
c$7126 ld a,(de)     ; Current byte from the font character
 $7127 ld (hl),a     ; Write byte to screen
 $7128 inc de        ; Next row of font pixels
 $7129 inc h         ; Next pixel line
 $712a djnz $7126    ; Repeat until 8x8 char displayed
 $712c pop de        ;
 $712d pop bc        ;
 $712e ld a,h        ; {Reset display line
 $712f sub $08       ;
 $7131 ld h,a        ; }
 $7132 inc l         ; Increment column
 $7133 ret           ;

; Display string (with colour) on the screen.
;
; Calculates the start location in the DISPLAY/ATTRIBUTE files for writing the
; string, then executes WriteAsciiChars, which writes each individual character
; to the screen.
;
;  Input:DE Text data block (expects first byte to be a colour attr).
;        HL Screen address for writing the text.
; Output:A' Colour attribute for the text.
;        DE' Address to the ASCII characters for displaying.
;        HL' Screen address of next location.
;        HL Attribute file address of next location.
@label=DisplayString
c$7134 push hl       ; Preserve display file address
 $7135 call $72d0    ; #REGhl=coord to screen address (using #REGhl)
 $7138 ld a,(de)     ; {#REGa'=colour attribute
 $7139 ex af,af'     ; }
 $713a inc de        ; #REGde=next colour attribute
 $713b exx           ;
 $713c pop hl        ; Set #REGhl back to screen address
 $713d call $71d6    ; #REGhl=coord to attribute file address (using #REGhl)

; Write a list of ASCII characters to the screen.
;
; Used by the routine at #R$62ca.
;
; Input:A' Colour byte for the entire string.
;       DE' Address to a list of ASCII character to display.
;       HL' Display file address for writing the string.
;       HL Attribute file address for writing the colour byte.
@label=WriteAsciiChars
c$7140 exx           ;
 $7141 ld a,(de)     ; #REGa=ASCII character value
 $7142 bit 7,a       ; {If EOL byte then extract and display character
 $7144 jr nz,$7151   ; }
 $7146 call $7115    ; Display font character
 $7149 inc de        ; Get next character
 $714a exx           ;
 $714b ex af,af'     ;
 $714c ld (hl),a     ; Write the colour attribute
 $714d inc l         ; Next column
 $714e ex af,af'     ; Put colour attribute back in #REGa'
 $714f jr $7140      ; Loop back and display next character

; Write an EOL character to the screen.
;
; Game strings (e.g. score labels) set bit-7 on the last character to indicate
; it is EOL. This bit needs to be reset before displaying the character on the
; screen.
;
; Input:A' Colour byte for the character.
;       A The EOL ASCII character to be displayed.
;       HL Screen address for writing the string.
;       HL' Attribute file address for writing the colour byte.
@label=WriteEOLChar
c$7151 and $7f       ; Turn off the EOL flag: bit-7
 $7153 call $7115    ; Display font character
 $7156 exx           ;
 $7157 ex af,af'     ;
 $7158 ld (hl),a     ; Write the colour byte
 $7159 ret           ;

; Displays score labels at top of screen.
;
; Used by the routine at #R$6064.
@label=DrawStatusBarLabels
c$715a ld hl,$0018   ; {Display "1UP" text at column 24
 $715d ld de,$7175   ;
 $7160 call $7134    ; }
 $7163 ld hl,$0078   ; {Display "HI" text at column 120
 $7166 ld de,$717d   ;
 $7169 call $7134    ; }
 $716c ld hl,$00d8   ; {Display "2UP" text at column 216
 $716f ld de,$7179   ;
 $7172 jp $7134      ; }

; GFX score labels.
;
; As displayed in the status bar - the last char includes an EOL bit ($80).
; #TABLE(default,centre,:w)
; { =h Bits(n) | =h Option }
; { 0 | Colour Attribute }
; { 1..n | ASCII char, n=EOL bit }
; TABLE#
@label=ScoreLabel1UP
b$7175 defb $47,$31,$55,$d0 ; WHITE "1UP" score label

; Data block at 7179
@label=ScoreLabel2UP
b$7179 defb $47,$32,$55,$d0 ; WHITE "2UP" score label

; Data block at 717d
@label=ScoreLabelHI
b$717d defb $45,$48,$c9 ; CYAN  "HI" score label

; Clears the entire ZX Spectrum display file.
;
; Used by the routine at #R$6064.
@label=ClearScreen
c$7180 ld hl,$4000   ; Beginning of display file
 $7183 ld b,$58      ; MSB to stop at (end of display file)

; Clear memory block with null.
;
; Used by the routine at #R$62fe.
;
; Input:B Loop counter: the MSB of the address to stop at.
;       HL Start address to begin filling.
@label=ClearMemoryBlock
c$7185 ld c,$00      ; Byte to use for the fill

; Fill a memory block with a byte value.
;
; Used by the routine at #R$718e.
;
; Input:B Loop counter: the MSB of the address to stop at.
;       C Fill byte.
;       HL Start address to begin filling.
@label=MemoryFill
c$7187 ld (hl),c     ; Write the fill byte
 $7188 inc hl        ;
 $7189 ld a,h        ;
 $718a cp b          ;
 $718b jr c,$7187    ; Repeat until #REGh matches #REGb
 $718d ret           ;

; Clears the entire ZX Spectrum attribute file.
;
; PAPER=black, INK=white.
@label=ClearAttrFile
c$718e ld hl,$5800   ; Attribute file
 $7191 ld b,$5b      ; MSB to stop at (end of attribute file)
 $7193 ld c,$47      ; Colour byte: PAPER=black, INK=white, BRIGHT
 $7195 jr $7187      ; Fill memory

; Colourize a sprite.
;
; Using Actor, adds colour to a sprite, working from bottom-to-top,
; left-to-right. This also handles sprites that are wrapped around the screen.
; Used by the routines at #R$63a3, #R$64a4, #R$650e, #R$6514, #R$6632, #R$66fc,
; #R$687a, #R$6d43, #R$6d9c and #R$7492.
;
; Input:IX Jetman/Alien object.
@label=ColourizeSprite
c$7197 exx           ;
 $7198 ld hl,($5dcf) ; #REGhl=actor coords
 $719b call $71d6    ; #REGhl=coord to attribute file address (using #REGhl)
@ssub=ld a,($5dc0+$04) ; Actor state "width"
 $719e ld a,($5dc4)  ;
 $71a1 ld b,a        ; #REGb=width loop counter (in pixels)
@ssub=ld a,($5dc0+$03) ; Actor state "height"
 $71a2 ld a,($5dc3)  ;
 $71a5 rrca          ;
 $71a6 rrca          ;
 $71a7 inc a         ;
 $71a8 rrca          ;
 $71a9 and $1f       ;
 $71ab inc a         ;
 $71ac ld c,a        ; #REGc=height loop counter (in pixels)
 $71ad ld d,(ix+$03) ; #REGd=object colour attribute
 $71b0 ld e,b        ; #REGe=width loop counter (in pixels)
*$71b1 push hl       ;
; Loop for updating attribute file with colour.
*$71b2 ld a,h        ; #REGa=actor Y position
 $71b3 cp $5b        ; {Decrement position if address is outside of attribute
 $71b5 jr nc,$71c8   ; file address range
 $71b7 cp $58        ;
 $71b9 jr c,$71c8    ; }
 $71bb ld (hl),d     ; Otherwise, set the colour at this location
 $71bc inc l         ; Next tile column
 $71bd ld a,l        ; {Next tile if column < screen width (32 chars)
 $71be and $1f       ;
 $71c0 jr nz,$71c6   ; }
 $71c2 ld a,l        ; else, wrap-around and continue applying colour
 $71c3 sub $20       ;
 $71c5 ld l,a        ; #REGl=start of current row
*$71c6 djnz $71b2    ; Loop back and continue with next tile
; Decrement the vertical position and colour the tiles.
*$71c8 pop hl        ;
 $71c9 push bc       ;
 $71ca and a         ; Clear Carry flag
 $71cb ld bc,$0020   ; {#REGhl -= 32 tiles. Places address pointer previous
 $71ce sbc hl,bc     ; line}
 $71d0 pop bc        ;
 $71d1 ld b,e        ; #REGb=reset to original width counter
 $71d2 dec c         ; Decrement height counter
 $71d3 jr nz,$71b1   ; Repeat until all tiles have been coloured
 $71d5 ret           ;

; Convert a Y,X pixel coordinate to an ATTRIBUTE_FILE address.
;
; Used by the routines at #R$61a0, #R$61ad, #R$62ca, #R$6fc5, #R$7134, #R$7197
; and #R$7638.
;
;  Input:H Vertical coordinate in pixels (0-191).
;        L Horizontal coordinate in pixels (0-255).
; Output:HL An address in the attribute file.
@label=Coord2AttrFile
c$71d6 ld a,l        ; Horizontal coordinate. Example, if $B8:
 $71d7 rrca          ; A=01011100, C=0
 $71d8 rrca          ; A=00101110, C=0
 $71d9 rrca          ; A=00010111, C=0
 $71da and $1f       ; A=00010111 <- screen width?
 $71dc ld l,a        ; #REGl=$17
 $71dd ld a,h        ; Vertical coordinate. Example, if $68:
 $71de rlca          ; A=00110100, C=0
 $71df rlca          ; A=00011010, C=0
 $71e0 ld c,a        ; Backup value to #REGc
 $71e1 and $e0       ; A=00000000
 $71e3 or l          ; A=00010111
 $71e4 ld l,a        ; #REGl=$17 <- new LSB of attribute file
 $71e5 ld a,c        ; Restore the row value
 $71e6 and $03       ; A=00000010 <- top of screen?
 $71e8 or $58        ; A=01011010
 $71ea ld h,a        ; #REGh=$5A <- ATTRIBUTE_FILE address (>= 5800)
 $71eb ret           ; Return #REGhl=5A17

; Generic jump routine for finding actor pos/dir.
;
; Used by the routines at #R$7232 and #R$726d.
@label=JumpActorFindPosDir
c$71ec call $7289    ; Find sprite using Actor

; Get location of Actor.
;
; Used by the routines at #R$7226 and #R$7268.
@label=GetActorLocation
c$71ef ld hl,($5dc0) ; #REGhl=Actor.X/Y position

; Get sprite position and dimensions.
;
; Note: the sprite header byte is added to the X position. So the question is:
; what is this header byte really for? Used by the routine at #R$687a.
;
;  Input:DE Address to the start of a Sprite or Buffer.
;        HL The Y,X coordinate of the sprite.
; Output:B Is the sprite width.
;        C Is always NULL.
;        HL Screen address of sprite.
;        DE Address pointing to the pixel data block.
@label=GetSpritePosition
c$71f2 ld a,(de)     ; #REGa=header value: X position offset?
 $71f3 inc de        ; #REGde=next header value: sprite width
 $71f4 add a,l       ; {#REGl=X position + offset
 $71f5 ld l,a        ; }
 $71f6 call $72d0    ; #REGhl=coord to screen address (using/returning #REGhl)
 $71f9 ld a,(de)     ; {#REGb=read sprite width again
 $71fa ld b,a        ; }
 $71fb inc de        ; {#REGa=next header value: sprite height
 $71fc ld a,(de)     ; }
@ssub=ld ($5dc0+$05),a ; Set Actor height to header height value
 $71fd ld ($5dc5),a  ;

; Increment #REGde to beginning of next sprite header.
;
; Used by the routines at #R$71f2 and #R$7207.
@label=NextSprite
c$7200 ld c,$00      ;
 $7202 inc de        ; #REGde=next header value: sprite data bytes
 $7203 ret           ;

; Find actor sprite address and update actor.
;
; Used by the routines at #R$7232 and #R$727d.
@label=FindActorSpriteAndUpdate
c$7204 call $72ab    ; Find actor position.

; Update actor state.
;
; Get sprite position/dimensions, and update actor. Used by the routines at
; #R$7226 and #R$7263.
;
;  Input:DE Address of header block for sprite or buffer data.
;        IX Actor object states: jetman, item, rocket, alien, etc.
; Output:B Is the sprite width.
;        C Is always NULL.
;        HL Pixel coordinates (Y/X) of the actor
;        DE Start address pointing at the "sprite data" block.
@label=ActorUpdate
c$7207 ld l,(ix+$01) ; #REGl=actor X location
 $720a ld h,(ix+$02) ; #REGh=actor Y location
 $720d ld a,(de)     ; #REGa=sprite header byte
 $720e inc de        ; #REGde=next header value: sprite width
 $720f add a,l       ; {#REGl=X column + header byte
 $7210 ld l,a        ; }
 $7211 ld ($5dcf),hl ; Set actor_coords variable with these actor coordinates
 $7214 call $72d0    ; #REGhl=coord to screen address (using #REGhl)
 $7217 ld a,(de)     ; {#REGb=sprite width
 $7218 ld b,a        ; }
@ssub=ld ($5dc0+$04),a ; Actor width=sprite width
 $7219 ld ($5dc4),a  ;
 $721c inc de        ; {#REGa=next header value: sprite height
 $721d ld a,(de)     ; }
@ssub=ld ($5dc0+$06),a ; Set Actor sprite height
 $721e ld ($5dc6),a  ;
@ssub=ld ($5dc0+$03),a ; Set Actor height to sprite height
 $7221 ld ($5dc3),a  ;
 $7224 jr $7200      ; Set return values (#REGde points to sprite pixel data)

; Update Actor X/Y positions.
;
; Used by the routines at #R$64a4 and #R$66fc.
@label=ActorUpdatePosition
c$7226 push de       ;
 $7227 call $71ef    ; #REGhl=Get sprite position
 $722a exx           ;
 $722b pop de        ;
 $722c call $7207    ; Update actor
 $722f exx           ;
 $7230 jr $7239      ; Erase actor sprite

; Now update and erase the actor.
;
; Used by the routines at #R$63a3, #R$650e, #R$6d43, #R$6d9c and #R$7492.
@label=UpdateAndEraseActor
c$7232 call $7204    ; Find sprite using X position and update actor
 $7235 exx           ;
 $7236 call $71ec    ; Find sprite using actor and get address

; Erase an actor sprite - after an it's been moved.
;
; Used by the routine at #R$7226.
;
; Input:IX Actor object.
@label=ActorEraseMovedSprite
@ssub=ld a,($5dc0+$01) ; #REGa=actor Y position
c$7239 ld a,($5dc1)  ;
 $723c sub (ix+$02)  ; Subtract the actor Y position
 $723f jp z,$7748    ; Update actor size if 0
 $7242 jp m,$7254    ; Jump if result is negative
 $7245 ld c,a        ; else #REGc=result
@ssub=ld a,($5dc0+$05) ; #REGa=actor current sprite height
 $7246 ld a,($5dc5)  ;
 $7249 cp c          ;
 $724a jp c,$7748    ; Update actor size if REGa < #REGc
 $724d sub c         ; else subtract #REGc
@ssub=ld ($5dc0+$05),a ; Update actor current sprite height
 $724e ld ($5dc5),a  ;
 $7251 jp $7705      ; Mask sprite pixels
*$7254 exx           ;
 $7255 neg           ;
 $7257 ld c,a        ;
@ssub=ld a,($5dc0+$06) ; #REGa=actor sprite height
 $7258 ld a,($5dc6)  ;
 $725b cp c          ;
 $725c jp c,$7747    ; Update actor size if < #REGc
 $725f sub c         ;
 $7260 jp $775b      ; Erase sprite pixels

; Find animation sprite position and erase its pixels.
;
; Used by the routines at #R$6514, #R$6632 and #R$687a.
@label=ActorEraseAnimSprite
c$7263 call $7207    ; Update the Actor
 $7266 jr $7280      ; Erase sprite pixels

; Find Actor position, then erase its sprite.
;
; Used by the routines at #R$6461 and #R$6632.
@label=ActorDestroy
c$7268 call $71ef    ; Get sprite position
 $726b jr $7270      ; Erase a destroyed actor

; Find an Actor and destroy it.
;
; Used by the routines at #R$6523, #R$6565, #R$66d0 and #R$687a.
@label=ActorFindDestroy
c$726d call $71ec    ; Find sprite and sprite position

; Erase a destroyed Actor.
;
; Used by the routines at #R$687a and #R$7268.
@label=ActorEraseDestroyed
c$7270 exx           ;
 $7271 xor a         ;
 $7272 ld c,a        ;
@ssub=ld ($5dc0+$06),a ; Actor sprite height = $00
 $7273 ld ($5dc6),a  ;
@ssub=ld ($5dc0+$03),a ; Actor "height" = $00
 $7276 ld ($5dc3),a  ;
 $7279 exx           ;
 $727a jp $7705      ; Mask sprite pixels

; Unused?
c$727d call $7204    ;

; Erase an animation sprite.
;
; Used by the routine at #R$7263.
@label=EraseAnimationSprite
c$7280 exx           ;
 $7281 xor a         ;
@ssub=ld ($5dc0+$05),a ; Actor current sprite height = $00
 $7282 ld ($5dc5),a  ;
 $7285 ld c,a        ; #REGc = $00
 $7286 jp $7705      ; Mask sprite pixels

; Find position and direction of an Actor.
;
; Used by the routine at #R$71ec.
@label=ActorFindPosDir
c$7289 ld a,($5dc0)  ; #REGa=actor X position
 $728c and $06       ;
 $728e ld c,a        ;
@ssub=ld a,($5dc0+$02) ; #REGa=actor movement direction
 $728f ld a,($5dc2)  ;

; Get actor sprite address.
;
; Used by the routine at #R$72ab.
;
;  Input:A Sprite header byte or Actor movement.
;        C Sprite header byte or X position.
; Output:DE Address for sprite.
@label=ActorGetSpriteAddress
c$7292 bit 6,a       ;
 $7294 jr z,$7298    ; Jump if bit-6 of header is reset
 $7296 set 3,c       ; else set bit-3 of X position
*$7298 dec a         ; {Calculate offset for sprite lookup table
 $7299 rlca          ;
 $729a rlca          ;
 $729b rlca          ;
 $729c rlca          ;
 $729d and $f0       ;
 $729f or c          ; }
 $72a0 ld c,a        ;
 $72a1 ld b,$00      ; #REGbc=lookup table offset
 $72a3 ld hl,$76c5   ; #REGhl=start of Jetman/Buffer sprite lookup tables
 $72a6 add hl,bc     ;
 $72a7 ld e,(hl)     ; {#REGde=sprite address
 $72a8 inc hl        ;
 $72a9 ld d,(hl)     ; }
 $72aa ret           ;

; Move an actor's sprite to it's current position.
;
; The IX register can point to one of the actor object types:
; `jetman_direction`, `item_state`, or one of the 6 `alien_states`.
; .
; Used by the routine at #R$7204.
;
; Input:IX actor object.
@label=ActorMoveSprite
c$72ab ld a,(ix+$01) ; #REGa=X position
 $72ae and $06       ;
 $72b0 ld c,a        ;
 $72b1 ld a,(ix+$00) ; #REGa=sprite header byte
 $72b4 jr $7292      ; Get sprite address

; Calculate screen address one pixel above current position.
;
; Calculates the new address for writing a sprite pixel, in an upward
; direction, taking into consideration the screen memory layout.
; .
; Used by the routine at #R$7705.
;
;  Input:HL Current position.
; Output:HL Address for new position.
@label=ScreenPosOnePixelAbove
c$72b6 dec h         ; Decrement #REGh to move up one pixel on screen
 $72b7 ld a,h        ;
 $72b8 and $07       ;
 $72ba cp $07        ; Has a character line been crossed?
 $72bc ret nz        ; If not, return
 $72bd ld a,l        ; {else subtract 32 from #REGl
 $72be sub $20       ;
 $72c0 ld l,a        ; }
 $72c1 and $e0       ;
 $72c3 cp $e0        ; Has a new section of the screen been crossed?
 $72c5 ret z         ; Return if not
 $72c6 ld a,h        ;
 $72c7 add a,$08     ;
 $72c9 ld h,a        ;
 $72ca ret           ;

; Unused code.
i$72cb

; Convert a Y,X pixel coordinate to a DISPLAY_FILE address.
;
; Used by the routines at #R$62ca, #R$6fc5, #R$706d, #R$7134, #R$71f2, #R$7207
; and #R$7638.
;
;  Input:H Vertical position in pixels (0-191).
;        L Horizontal position in pixels (0-255).
; Output:HL An address in the display file.
@label=Coord2Scr
c$72d0 ld a,l        ; Horizontal coordinate. Example, if $B8:
 $72d1 rrca          ; A=01011100, C=0
 $72d2 rrca          ; A=00101110, C=0
 $72d3 rrca          ; A=00010111, C=0
 $72d4 and $1f       ; A=00010111 <- screen width?
 $72d6 ld l,a        ; #REGl=$17
 $72d7 ld a,h        ; Vertical coordinate. Example, if $68:
 $72d8 rlca          ; A=00110100, C=0
 $72d9 rlca          ; A=00011010, C=0
 $72da and $e0       ; A=00000000
 $72dc or l          ; A=00010111
 $72dd ld l,a        ; #REGl=$17 <- new LSB of attribute file
 $72de ld a,h        ; Vertical coordinate. Example, if $68:
 $72df and $07       ; A=00000100
 $72e1 ex af,af'     ; Puts the value into the shadow register
 $72e2 ld a,h        ; Vertical coordinate. Example, if $68:
 $72e3 rrca          ; A=00110100, C=0
 $72e4 rrca          ; A=00011010, C=0
 $72e5 rrca          ; A=00001101, C=0
 $72e6 and $18       ; A=00001000
 $72e8 or $40        ; A=00101000
 $72ea ld h,a        ; #REGhl=$48
 $72eb ex af,af'     ; Get the shadow register value
 $72ec or h          ; A=00101100
 $72ed ld h,a        ; #REGh=$4C <- DISPLAY_FILE address (>= 4000)
 $72ee ret           ; Return #REGhl=4C68

; Copy actor position/direction values to Actor.
;
; Used by the routines at #R$6461, #R$64e8, #R$6523, #R$6690, #R$66b4, #R$66d0,
; #R$687a, #R$6cb0, #R$6d9c, #R$739e and #R$753c.
;
; Input:IX Jetman object.
@label=ActorUpdatePosDir
c$72ef ld a,(ix+$01) ; {Actor X position = Jetman X position
 $72f2 ld ($5dc0),a  ; }
 $72f5 ld a,(ix+$02) ;
@ssub=ld ($5dc0+$01),a ; Actor Y position = Jetman Y position
 $72f8 ld ($5dc1),a  ;
 $72fb ld a,(ix+$00) ;
@ssub=ld ($5dc0+$02),a ; Actor movement = Jetman direction
 $72fe ld ($5dc2),a  ;
 $7301 ret           ;

; Joystick Input (Interface 2)
;
; The ROM cartridge was made for the Interface 2 which reads the Joystick I
; bits in the format of 000LRDUF, which are mapped to the keyboard keys: 6, 7,
; 8, 9, and 0. Note that a reset bit means the button is pressed.
; .
; Used by the routines at #R$7309, #R$733f, #R$735e and #R$743e.
;
; Output:A Joystick direction/button state.
@label=ReadInterface2Joystick
c$7302 ld a,$ef      ; Interface 2 Joystick port
 $7304 out ($fb),a   ;
 $7306 in a,($fe)    ; #REGa = bits for 000LRDUF
 $7308 ret           ;

; Read input from the keyboard port.
;
; Used by the routines at #R$739e and #R$753c.
;
; Output:A direction values $EF (L), $F7 (R) or $FF for no input detected -
; .        like joystick: 000LRDUF.
@label=ReadInputLR
c$7309 ld a,($5cf3)  ; Game options
 $730c bit 1,a       ; Use Joystick?
 $730e jr nz,$7302   ; Jump if so
; Read bottom-left row of keys.
 $7310 ld a,$fe      ; Row: Shift,Z,X,C,V
 $7312 out ($fd),a   ; Set port for reading keyboard
 $7314 in a,($fe)    ; ...and read that row of keys
 $7316 and $1e       ;
 $7318 cp $1e        ; Check if any keys on the row are pressed
 $731a jr z,$7324    ; Jump if not - read inputs again
 $731c and $14       ; Reset all bits except X and V keys (RIGHT keys)
 $731e cp $14        ; Check if neither are pressed (reset)
 $7320 jr z,$7336    ; If so, a LEFT key was pressed: Z and C
 $7322 jr $7339      ; else RIGHT key was pressed: X and V
; Read bottom-right row of keys.
*$7324 ld a,$7f      ; Row: B,N,M.Sym,Sp
 $7326 out ($fd),a   ; Set port for reading keyboard
 $7328 in a,($fe)    ; ...and read that row of keys
 $732a and $1e       ;
 $732c cp $1e        ; Check if any keys on the row are pressed
 $732e jr z,$733c    ; Jump if not - no input detected.
 $7330 and $14       ; Reset all bits except B and M keys (LEFT keys)
 $7332 cp $14        ; Check if neither are pressed (reset)
 $7334 jr z,$7339    ; If so, a RIGHT key was pressed: N and Sym
*$7336 ld a,$ef      ; #REGa=LEFT_KEY  : 1110 1111
 $7338 ret           ;
*$7339 ld a,$f7      ; #REGa=RIGHT_KEY : 1111 0111
 $733b ret           ;
*$733c ld a,$ff      ; #REGa=No input detected
 $733e ret           ;

; Check if fire button is pressed.
;
; Used by the routine at #R$7492.
;
; Output:A fire button, $FE = pressed, $FF = no input - like joystick:
; .        000LRDUF.
@label=ReadInputFire
c$733f ld a,($5cf3)  ; Game options
 $7342 bit 1,a       ; Use Joystick?
 $7344 jr nz,$7302   ; Jump if so
 $7346 ld b,$02      ; Loop count: read left and right row of keys
 $7348 ld a,$fd      ; Row: A,S,D,F,G
*$734a out ($fd),a   ; Set port for reading keyboard
 $734c in a,($fe)    ; ...and read that row of keys
 $734e and $1f       ;
 $7350 cp $1f        ; Check if any keys on the row are pressed
 $7352 jr nz,$735b   ; Jump if so - key press detected
 $7354 ld a,$bf      ; Row: H,J,K,L,Enter
 $7356 djnz $734a    ; Loop back and read input again
 $7358 ld a,$ff      ; Still no input detected
 $735a ret           ;
*$735b ld a,$fe      ; #REGa=FIRE : 1111 1110
 $735d ret           ;

; Check if thrust (up) button is pressed.
;
; Used by the routines at #R$7412 and #R$753c.
;
; Output:A thrust button, $FE = pressed, $FF = no input - like joystick:
; .        000LRDUF.
@label=ReadInputThrust
c$735e ld a,($5cf3)  ; Game options
 $7361 bit 1,a       ; Use Joystick?
 $7363 jr nz,$7302   ; Jump if so
 $7365 ld b,$02      ; Loop count: read left and right row of keys
 $7367 ld a,$fb      ; Row: Q,W,E,R,T
*$7369 out ($fd),a   ; Set port for reading keyboard
 $736b in a,($fe)    ; ...and read that row of keys
 $736d and $1f       ;
 $736f cp $1f        ; Check if any keys on the row are pressed
 $7371 jr nz,$737a   ; Jump if so - key press detected
 $7373 ld a,$df      ; Row: Y,U,I,O,P
 $7375 djnz $7369    ; Loop back and read input again
 $7377 ld a,$ff      ; Still no input detected
 $7379 ret           ;
*$737a ld a,$fd      ; #REGa=UP (thrust) : 1111 1101
 $737c ret           ;

; Game play starts, or prepare new turn, or check Jetman thrust input.
@label=GamePlayStarts
c$737d ld hl,$5dd7   ; {If begin play delay timer is zero (turn started), check
 $7380 ld a,(hl)     ; to see if player is thrusting
 $7381 and a         ;
 $7382 jr z,$739e    ; }
 $7384 dec (hl)      ; else decrement timer
 $7385 jp nz,$6197   ; Flash Score label if still not zero
 $7388 call $67d2    ; SFX to indicate play is about to start!
 $738b ld a,($5dd1)  ; {Stop flashing 2UP if current player number is 2
 $738e and a         ;
 $738f jr nz,$7399   ; }
 $7391 ld hl,$0018   ; {Stop flashing "1UP" text
*$7394 call $61ad    ; }
 $7397 jr $739e      ; Check if player is thrusting
*$7399 ld hl,$00d8   ; {Stop flashing "2UP" text
 $739c jr $7394      ; }

; Airborne Jetman update.
;
; Read thrust/direction controls and update position accordingly. Used by the
; routine at #R$737d.
;
; Input:IX Jetman object.
@label=JetmanFlyThrust
c$739e call $72ef     ; Update actor position direction
 $73a1 call $7309     ; Read Left/Right input
 $73a4 bit 3,a        ; {Update Jetman direction for THRUST RIGHT
 $73a6 jp z,$73b8     ; }
 $73a9 bit 4,a        ; {Jetman thrust left
 $73ab jp z,$7501     ; }
 $73ae ld a,($5dcc)   ; Game timer
 $73b1 and $01        ; {If bit-0 is reset, fly horizontal
 $73b3 jr z,$73da     ; }
 $73b5 jp $752d       ; Calculate new horizontal speed
*$73b8 res 6,(ix+$00) ; Set Jetman direction to be "right"
 $73bc bit 6,(ix+$04) ; {Flip direction if currently moving left
 $73c0 jp nz,$750c    ; }

; Increase Jetman horizontal speed.
;
; Used by the routine at #R$7501.
;
; Input:IX Jetman object.
@label=JetmanFlyIncSpdX
c$73c3 ld a,($5dca)   ; Jetman speed modifier ($00 or $04)
 $73c6 neg            ;
 $73c8 add a,$08      ;
 $73ca add a,(ix+$05) ; #REGa += Jetman X speed
 $73cd cp $40         ;
 $73cf jr nc,$73d6    ; Jump if speed >= max

; Update Jetman X speed with new value.
;
; Used by the routines at #R$750c and #R$752d.
@label=JetmanFlySetSpdX
c$73d1 ld (ix+$05),a ; Update Jetman X speed with #REGa (will be < 64)
 $73d4 jr $73da      ; Fly horizontally

; Set Jetman X speed to the max flying speed.
;
; Used by the routine at #R$73c3.
@label=JetmanFlySetMaxSpdX
c$73d6 ld (ix+$05),$40 ;

; Fly Jetman horizontally.
;
; Used by the routines at #R$739e, #R$73d1 and #R$750c.
;
;  Input:IX Jetman object.
; Output:H New X position.
;        L New Thrust value.
@label=JetmanFlyHorizontal
c$73da ld h,$00       ;
 $73dc ld l,(ix+$05)  ; Jetman X speed (will be <= 64)
 $73df add hl,hl      ; {Multiply X speed by 3
 $73e0 add hl,hl      ;
 $73e1 add hl,hl      ; }
 $73e2 ld d,(ix+$01)  ; #REGd=Jetman X position
@ssub=ld a,($5dc0+$07) ; Actor thrust
 $73e5 ld a,($5dc7)   ;
 $73e8 ld e,a         ;
 $73e9 bit 6,(ix+$04) ; {Decrease Jetman X position if moving right
 $73ed jp nz,$74fa    ; }
 $73f0 add hl,de      ; else, increase X position

; Apply gravity to Jetman if no thrust button detected.
;
; Used by the routine at #R$74fa.
;
; Input:IX Jetman object.
;       H New X position.
;       L New Thrust value.
@label=JetmanApplyGravity
c$73f1 ld a,l        ;
@ssub=ld ($5dc0+$07),a ; Update Actor thrust
 $73f2 ld ($5dc7),a  ;
 $73f5 ld (ix+$01),h ; Set new Jetman X position
; Check if thruster is being aplpied
 $73f8 ld a,($5cf3)  ; Game options
 $73fb bit 1,a       ; {Use Joystick? Jump if so.
 $73fd jp nz,$743e   ; }
; Induce a slight pause before reading keys - this is required so that the
; gravity kicks in. It also acts as an undocumented hover key.
 $7400 ld b,$02      ; Loop count: read left and right row of keys
 $7402 ld a,$ef      ; Read top-right row of keys
*$7404 out ($fd),a   ; Set port for reading keyboard
 $7406 in a,($fe)    ; ...and read that row of keys
 $7408 and $1f       ;
 $740a cp $1f        ; Check if any keys on the row are pressed
 $740c jr nz,$7438   ; Jump if so - hover Jetman
 $740e ld a,$f7      ; Read top-left row of keys
 $7410 djnz $7404    ; ...and repeat

; Check if Jetman is moving falling downward.
;
; Used by the routine at #R$743e.
@label=JetmanFlyCheckFalling
c$7412 call $735e     ; Check if THRUST button pressed (Joystick or Keys)
 $7415 bit 1,a        ; {Set Jetman to down position if not thrusting
 $7417 jp nz,$74d5    ; }
 $741a res 7,(ix+$00) ; {Jetman direction is DOWN or WALKing
 $741e bit 7,(ix+$04) ; }
 $7422 jp nz,$74e0    ; Flip vertical direction if moving down

; Increase Jetman vertical speed.
;
; Used by the routine at #R$74d5.
@label=JetmanSpeedIncY
c$7425 ld a,($5dca)   ; Jetman speed modifier ($00 or $04)
 $7428 neg            ;
 $742a add a,$08      ;
 $742c add a,(ix+$06) ; #REGa += Jetman Y speed
 $742f cp $3f         ;
 $7431 jr nc,$7448    ; Set vertical speed to max if >= 63

; Update Jetman vertical speed with new value.
;
; Used by the routine at #R$74e0.
@label=JetmanSetSpdY
c$7433 ld (ix+$06),a ; Y speed = #REGa (is < 63)
 $7436 jr $744c      ; Update vertical flying

; Set Jetman vertical speed to zero.
;
; Used by the routines at #R$73f1 and #R$743e.
@label=JetmanSetZeroSpdY
c$7438 ld (ix+$06),$00 ; Jetman Y speed is zero
 $743c jr $744c        ; Update vertical flying

; Check joystick input for FIRE or THRUST.
;
; Used by the routine at #R$73f1.
@label=JetmanFlyCheckThrusting
c$743e call $7302    ; Read Joystick
 $7441 bit 2,a       ; {Set Y speed to zero if not thrusting
 $7443 jp z,$7438    ; }
 $7446 jr $7412      ; else check if falling and update movement

; Set Jetman vertical speed to maximum.
;
; Used by the routine at #R$7425.
@label=JetmanSetMaxSpdY
c$7448 ld (ix+$06),$3f ; Set Jetman Y speed to 63

; Fly Jetman vertically.
;
; Used by the routines at #R$7433, #R$7438 and #R$74e0.
;
; Input:IX Jetman object.
@label=JetmanFlyVertical
c$744c ld l,(ix+$06)  ; #REGl=Jetman Y speed (will be <= 63)
 $744f ld h,$00       ;
 $7451 add hl,hl      ; {Multiply vertical X speed by 3
 $7452 add hl,hl      ;
 $7453 add hl,hl      ; }
 $7454 ld d,(ix+$02)  ; #REGd=Jetman Y position
 $7457 ld a,($5dc8)   ; {#REGe=Jetman flying counter
 $745a ld e,a         ; }
 $745b bit 7,(ix+$04) ; {Move Jetman up if moving up
 $745f jp z,$7526     ; }
 $7462 add hl,de      ; else move downwards

; Check vertical position while in mid-flight.
;
; Used by the routine at #R$7526.
@label=JetmanFlyCheckPosY
c$7463 ld a,l        ; {Update Jetman flying counter
 $7464 ld ($5dc8),a  ; }
 $7467 ld (ix+$02),h ; Update Jetman Y position
 $746a ld a,h        ;
 $746b cp $c0        ;
 $746d jr nc,$74bf   ; Move up if within screen limits: 42 to 192
 $746f cp $2a        ;
 $7471 jr c,$74c5    ; Check if hit top of screen

; Jetman flight collision detection.
;
; Used by the routines at #R$74bf and #R$74c5.
;
; Input:IX Jetman object.
@label=JetmanCollision
c$7473 call $75e8    ; Platform collision detection (returns #REGe)
 $7476 bit 2,e       ; {Redraw Jetman if bit-2 has not been set
 $7478 jr z,$7492    ; }
 $747a bit 7,e       ; {Jetman lands on top of a platform
 $747c jp nz,$74a7   ; }
 $747f bit 4,e       ; {Jetman hits bottom of a platform
 $7481 jr nz,$74a1   ; }
; Jetman hits platform edge.
 $7483 ld a,e        ;
 $7484 xor $40       ; {Update #REGe to be either $00 or $40.
 $7486 and $40       ;
 $7488 ld e,a        ; }
 $7489 ld a,(ix+$04) ; {Update Jetman moving direction
 $748c and $bf       ;
 $748e or e          ;
 $748f ld (ix+$04),a ; }

; Redraw Jetman sprite on the screen.
;
; Every time this function is called, a check is also made to see if the player
; is pressing the fire button, and draws a laser beam if so.
@label=JetmanRedraw
c$7492 call $7232    ; Update and erase the actor
 $7495 call $7197    ; Colour the sprite
 $7498 call $733f    ; Read the input for a FIRE button
 $749b bit 0,a       ;
 $749d call z,$6f5a  ; If pressed, Fire laser (if free slot is available)
 $74a0 ret           ;

; Jetman hits the underneath of a platform.
;
; Used by the routine at #R$7473.
@label=JetmanBumpsHead
c$74a1 set 7,(ix+$04) ; Set Jetman to be moving down
 $74a5 jr $7492       ; Redraw Jetman

; Jetman lands on a platform.
;
; Used by the routine at #R$7473.
@label=JetmanLands
c$74a7 res 7,(ix+$04)  ; Set Jetman to be standing still
 $74ab ld a,(ix+$00)   ; Jetman direction
 $74ae and $c0         ; Reset FLY and WALK bits
 $74b0 or $02          ; Now set movement to WALK
 $74b2 ld (ix+$00),a   ; Update Jetman direction to be walking
 $74b5 ld (ix+$05),$00 ; Set Jetman X speed to stopped
 $74b9 ld (ix+$06),$00 ; Set Jetman Y speed to stopped
 $74bd jr $7492        ; Redraw Jetman

; Reset Jetman movement direction.
;
; Used by the routine at #R$7463.
@label=JetmanSetMoveUp
c$74bf res 7,(ix+$04) ; Set Jetman to be moving up
 $74c3 jr $7473       ; Jetman flight collision detection

; Jetman hits the top of the screen.
;
; Used by the routine at #R$7463.
@label=JetmanHitScreenTop
c$74c5 set 7,(ix+$04) ; Set Jetman to be moving down
 $74c9 ld a,(ix+$06)  ; Jetman Y speed
 $74cc srl a          ;
 $74ce jr z,$7473     ; Jetman collision detection if #REGa was $00 or $01
 $74d0 ld (ix+$06),a  ; Update Jetman Y speed
 $74d3 jr $7473       ; Jetman flight collision detection

; Jetman is falling.
;
; Used by the routine at #R$7412.
@label=JetmanSetMoveDown
c$74d5 set 7,(ix+$00) ; Set Jetman direction to WALK/DOWN
 $74d9 bit 7,(ix+$04) ; {Increment Jetman Y speed if moving down
 $74dd jp nz,$7425    ; }

; Flip vertical direction Jetman is flying.
;
; Used by the routine at #R$7412.
@label=JetmanDirFlipY
c$74e0 ld a,($5dca)    ; Jetman speed modifier ($00 or $04)
 $74e3 sub $08         ; #REGa=$F8 or $FC
 $74e5 add a,(ix+$06)  ; #REGa += Jetman Y speed
 $74e8 jp p,$7433      ; Update vertical speed if new speed is positive
 $74eb ld (ix+$06),$00 ; else set Y speed to zero
 $74ef ld a,(ix+$04)   ; {Flip Jetman vertical moving direction
 $74f2 xor $80         ;
 $74f4 ld (ix+$04),a   ; }
 $74f7 jp $744c        ; Fly Jetman vertically

; Decrease Jetman X position.
;
; Used by the routine at #R$73da.
@label=JetmanFlyDecreasePosX
c$74fa and a         ; Reset Carry flag
 $74fb ex de,hl      ;
 $74fc sbc hl,de     ;
 $74fe jp $73f1      ; Update Jetman speed/dir if thrusting

; Jetman THRUST-LEFT input.
;
; Used by the routine at #R$739e.
@label=JetmanFlyThrustLeft
c$7501 set 6,(ix+$00) ; Set Jetman direction to be LEFT
 $7505 bit 6,(ix+$04) ; {Increase Jetman X speed if moving RIGHT
 $7509 jp nz,$73c3    ; }

; Flip Jetman left/right flying direction.
;
; Used by the routine at #R$739e.
@label=JetmanDirFlipX
c$750c ld a,($5dca)    ; Jetman speed modifier ($00 or $04)
 $750f sub $08         ; #REGa=$F8 or $FC
 $7511 add a,(ix+$05)  ; #REGa += Jetman X speed
 $7514 jp p,$73d1      ; Update horizontal speed if new speed is positive
 $7517 ld (ix+$05),$00 ; else set X speed to zero
 $751b ld a,(ix+$04)   ; {Flip Jetman left/right moving direction
 $751e xor $40         ;
 $7520 ld (ix+$04),a   ; }
 $7523 jp $73da        ; Fly Jetman vertically

; Move Jetman up: decrease Y position.
;
; Used by the routine at #R$744c.
@label=JetmanFlyMoveUp
c$7526 and a         ; Reset Carry flag
 $7527 ex de,hl      ;
 $7528 sbc hl,de     ; Move upwards
 $752a jp $7463      ; Check vertical position within screen limits

; Calculate new Jetman horizontal speed.
;
; Used by the routine at #R$739e.
@label=JetmanFlyCalcSpeedX
c$752d ld a,($5dca)   ; Jetman speed modifier ($00 or $04)
 $7530 sub $08        ; #REGa=$F8 or $FC
 $7532 add a,(ix+$05) ; #REGa += Jetman X speed
 $7535 jp p,$73d1     ; Update horizontal speed if new speed is positive
 $7538 xor a          ;
 $7539 jp $73d1       ; Update horizontal speed to zero

; Jetman walking.
;
; .
;
; Input:IX Jetman object.
@label=JetmanWalk
c$753c call $72ef      ; Update Actor position direction
 $753f call $7309      ; Read Left/Right input
 $7542 bit 3,a         ; {Walk RIGHT
 $7544 jr z,$75ad      ; }
 $7546 bit 4,a         ; {Walk LEFT
 $7548 jp z,$75bf      ; }
 $754b ld (ix+$05),$00 ; else set Jetman X speed to zero
*$754f call $735e      ; Read THRUST button
 $7552 bit 1,a         ; {Walk off platform if thrusting
 $7554 jr z,$757f      ; }
 $7556 call $75e8      ; Platform collision check (returns #REGe)
 $7559 bit 2,e         ; {Leave platform if bit-2 is reset
 $755b jr z,$757f      ; }
 $755d bit 3,e         ; {Redraw Jetman if bit-3 is reset
 $755f jp z,$7492      ; }
 $7562 ld a,(ix+$05)   ; Jetman X speed
 $7565 and a           ;
 $7566 jp nz,$7492     ; Redraw Jetman if X speed > 0
 $7569 bit 6,(ix+$00)  ; {Jetman leaves a platform, either left or right based
 $756d jr z,$7575      ; on the value of bit-6. The X position is dec/inc
 $756f dec (ix+$01)    ; appropriately, and the Redraw Jetman routine is
 $7572 jp $7492        ; called. Note also that the X speed is set to max
*$7575 inc (ix+$01)    ; walking speed, but this instruction might be
 $7578 ld (ix+$05),$20 ; irrelevant as hacking the speed value has no
 $757c jp $7492        ; noticeable effect.}
; Jetman leaves a platform by thrusters or by walking.
@label=JetmanWalkOffPlatform
*$757f ld a,(ix+$00)   ; Jetman direction
 $7582 and $c0         ; Reset FLY and WALK bits
 $7584 or $01          ; Now set movement to FLY
 $7586 ld (ix+$00),a   ; Update Jetman direction to be flying
 $7589 ld hl,($5d01)   ; #REGhl=Jetman Y,X position
 $758c push ix         ;
 $758e ld ix,$5d48     ; #REGix=Jetman thruster animation object
 $7592 ld a,(ix+$00)   ; {Jump if thrusters are already being animated
 $7595 and a           ;
 $7596 jr nz,$75a2     ; }
 $7598 ld (ix+$00),$03 ; else set thrusters to be animating?
@ssub=ld ($5d48+$01),hl ; Update thruster animation Y,X position
 $759c ld ($5d49),hl   ;
 $759f call $685d      ; Update actor movement states
*$75a2 pop ix          ; Restore #REGix to Jetman object
 $75a4 dec (ix+$02)    ; {Jetman Y position -= 2
 $75a7 dec (ix+$02)    ; }
 $75aa jp $7492        ; Redraw Jetman
; Jetman walks right.
*$75ad inc (ix+$01)    ; Jetman X position += 1
 $75b0 res 6,(ix+$00)  ; Jetman direction is right
 $75b4 res 6,(ix+$04)  ; Jetman moving direction to right
 $75b8 ld (ix+$05),$20 ; Set Jetman X speed to maximum
 $75bc jp $754f        ; Loop back, checking again for THRUST input
; Jetman walks left.
*$75bf dec (ix+$01)    ; Jetman X position -= 1
 $75c2 set 6,(ix+$00)  ; Jetman direction is left
 $75c6 set 6,(ix+$04)  ; Jetman moving direction to left
 $75ca ld (ix+$05),$20 ; Set Jetman X speed to maximum
 $75ce jp $754f        ; Loop back, checking again for THRUST input

; Related to horizontal platform collision detection - possibly flipping
; between sprite X position collision and Jetman direction collision...needs
; more work!
;
; Used by the routine at #R$75ed.
;
; Input:A Sprite X position minus Platform X position?
;       IX Jetman or alien.
c$75d1 ex af,af'     ;
 $75d2 ld a,(ix+$00) ; Jetman/alien direction
 $75d5 and $3f       ; Value must be <= 63
 $75d7 cp $03        ; {Jump if value == 3 (therefore never when Jetman)
 $75d9 jr z,$75de    ; }
 $75db ex af,af'     ; Restore #REGa to entry value
 $75dc jr $75fc      ; Vertical collision detection
*$75de ex af,af'     ; Flip again
 $75df sub $09       ;
 $75e1 jp p,$75fc    ; {Vertical collision detection, first incrementing by $09
 $75e4 add a,$09     ; if #REGa is negative
 $75e6 jr $75fc      ; }

; Jetman/platform collision detection.
;
; NOTE: collision detection is location based not pixel/colour based, so even
; if platform tiles are not drawn, a collision will be detected! Used by the
; routines at #R$63a3, #R$6461, #R$64e8, #R$6a35, #R$6ab8, #R$6bf8, #R$6cd7,
; #R$6d9c, #R$7473 and #R$753c.
;
;  Input:IX Jetman or Alien object.
; Output:E Collision state.
@label=JetmanPlatformCollision
c$75e8 ld b,$04      ; Loop counter (4 platforms to check)
 $75ea ld hl,$6003   ; Platform location/size params

; Horizontal platform collision detection for Jetman/Alien.
;
; Used by the routine at #R$75fc.
;
; Input:HL Address of platform object.
;       IX Jetman or Alien object.
@label=JetmanPlatformCollisionX
c$75ed ld e,$00      ;
 $75ef push hl       ;
 $75f0 inc hl        ; {#REGa=Platform X position
 $75f1 ld a,(hl)     ; }
 $75f2 sub (ix+$01)  ; Subtract Jetman/Alien X position
 $75f5 jp p,$75d1    ; If positive, Horizontal collision detection
 $75f8 neg           ;
 $75fa set 6,e       ; Set bit-6 and then vertical collision detection

; Vertical platform collision detection for Jetman/Aliens.
;
; Used by the routine at #R$75d1.
;
;  Input:A Sprite X position.
;        E Collision state on entry.
;        HL Address of platform object.
;        IX Jetman/Alien object.
; Output:E Collision state. Bit: 7=landed, 4=hits head, 3=?, 2=?.
@label=JetmanPlatformCollisionY
c$75fc inc hl        ; Platform Y location
 $75fd inc hl        ; Platform width
 $75fe cp (hl)       ; {X position >= width (no collision) so try next platform
 $75ff jp nc,$7630   ; }
 $7602 add a,$12     ;
 $7604 cp (hl)       ; {Set bit 3 if collision: X position >= width
 $7605 jp c,$760a    ;
 $7608 set 3,e       ; }
*$760a dec hl        ; Platform Y location
 $760b ld a,(hl)     ; #REGa=platform Y position
 $760c sub (ix+$02)  ; Subtract sprite Y position
 $760f neg           ;
 $7611 inc a         ; {Add 2
 $7612 inc a         ; }
 $7613 jp m,$7630    ; Next platform if no collision: Y position is negative
 $7616 cp $02        ; {#REGa < 2, Landed on platform
 $7618 jr c,$762c    ; }
 $761a cp (ix+$07)   ; {#REGa < sprite height, hits underneath of platform?
 $761d jr c,$7628    ; }
 $761f dec a         ; {Subtract 2
 $7620 dec a         ; }
 $7621 cp (ix+$07)   ; {Next platform if no collision: Y position >= sprite
 $7624 jr nc,$7630   ; height}
; Jetman hits the bottom of a platform
 $7626 set 4,e       ;
*$7628 set 2,e       ; Set bit-2 (4) <- Jetman is leaving a platform?
 $762a pop hl        ; Set #REGhl back to beginning of platform object
 $762b ret           ;
*$762c set 7,e       ; Bit-7 indicates landing on a platform
 $762e jr $7628      ;
*$7630 pop hl        ; Set #REGhl back to beginning of platform object
 $7631 inc hl        ; {Increment #REGhl until is points to the start of the
 $7632 inc hl        ; next platform sprite
 $7633 inc hl        ;
 $7634 inc hl        ; }
 $7635 djnz $75ed    ; Loop back until all 4 platforms have been checked
 $7637 ret           ;

; Displays platforms on screen.
;
; Used by the routine at #R$6094.
@label=DrawPlatforms
c$7638 ld b,$04      ; Loop counter (4 platforms for draw)
 $763a ld hl,$6003   ; Platform location/size params
*$763d push bc       ; Backup loop counter
 $763e ld a,(hl)     ; {Process next platform if sprite colour is black/unused
 $763f and a         ;
 $7640 jp z,$769e    ; }
 $7643 inc hl        ; {#REGc=X position
 $7644 ld c,(hl)     ; }
 $7645 inc hl        ;
 $7646 inc hl        ;
 $7647 ld a,(hl)     ; #REGa=platform width
 $7648 and $fc       ;
 $764a neg           ;
 $764c add a,c       ; #REGa += platform X position
 $764d add a,$10     ; #REGa += 16
 $764f push hl       ;
 $7650 dec hl        ; {#REGh=Y position byte
 $7651 ld h,(hl)     ; }
 $7652 ld l,a        ; #REGl=new X position
 $7653 call $72d0    ; #REGhl=coord to screen address (using #REGhl)
 $7656 ld de,$76ad   ; #REGde=address for LEFT platform sprite
 $7659 call $76a6    ; Draw LEFT platform tile pixels
 $765c ex (sp),hl    ; {Does this fetch the platform width value?
 $765d ld a,(hl)     ;
 $765e ex (sp),hl    ;
 $765f srl a         ;
 $7661 srl a         ;
 $7663 sub $04       ; }
 $7665 ld b,a        ; #REGb=loop counter for # of middle platform sprites
 $7666 ld de,$76b5   ; #REGde=address for MIDDLE platform sprite
*$7669 call $76a6    ; {Draw (all) MIDDLE platform tiles pixels
 $766c djnz $7669    ; }
 $766e ld de,$76bd   ; #REGde=address for RIGHT platform sprite
 $7671 call $76a6    ; Draw RIGHT platform tile pixels
 $7674 pop hl        ;
 $7675 ld a,(hl)     ; #REGa=platform width
 $7676 and $fc       ;
 $7678 neg           ;
 $767a add a,c       ; #REGa += X position
 $767b add a,$10     ; #REGa += 16
 $767d push hl       ;
 $767e dec hl        ; {#REGb=Y position
 $767f ld b,(hl)     ; }
 $7680 dec hl        ; {#REGc=colour attribute
 $7681 dec hl        ;
 $7682 ld c,(hl)     ; }
 $7683 ld h,b        ; {#REGhl=Y,X position
 $7684 ld l,a        ; }
 $7685 push bc       ;
 $7686 call $71d6    ; #REGhl=coord to attribute file address (using #REGhl)
 $7689 pop bc        ;
 $768a ex (sp),hl    ; {Does this fetch the platform width value?
 $768b ld a,(hl)     ;
 $768c ex (sp),hl    ;
 $768d srl a         ;
 $768f srl a         ;
 $7691 sub $02       ; }
 $7693 ld b,a        ; #REGb=loop counter for # of middle platform sprites
 $7694 ld a,c        ; {Apply platform colour to ATTRIBUTE_FILE
*$7695 ld (hl),a     ; }
 $7696 inc hl        ; #REGhl=next sprite position
 $7697 djnz $7695    ; Repeat until all sprites are coloured
 $7699 pop hl        ; Restore #REGhl=platform object at "width" byte
 $769a inc hl        ; #REGhl=beginning of next platform struct
 $769b pop bc        ; Restore #REGbc for loop counter
 $769c jr $76a3      ; Loop back and processing next platform
; These instructions are only called if current platform colour was black. Why
; would a platform colour be black?
*$769e pop bc        ; restore loop counter
 $769f inc hl        ; {Place #REGhl to beginning of next platform struct
 $76a0 inc hl        ;
 $76a1 inc hl        ;
 $76a2 inc hl        ; }
*$76a3 djnz $763d    ; Loop back and process next platform
 $76a5 ret           ;

; Draws the pixels for a platform sprite to the screen.
;
; Used by the routine at #R$7638.
@label=DrawPlatformTile
c$76a6 push bc       ;
 $76a7 push de       ;
 $76a8 ld b,$08      ; Loop counter (8x8 pixel)
 $76aa jp $7126      ; Draw character pixels for tile

; Platform sprite: left.
@label=tile_platform_left
b$76ad defb $2f,$7f,$ff,$dd,$fb,$7b,$71,$21

; Platform sprite: middle (repeated for width).
@label=tile_platfor_mmiddle
b$76b5 defb $bd,$ff,$ff,$f7,$eb,$dd,$ad,$04

; Platform sprite: right.
@label=tile_platform_right
b$76bd defb $4c,$fe,$ff,$3e,$ff,$fe,$9c,$08

; Sprite/Buffer lookup tables.
;
; The following 3 lookup tables must remain together as they are all accessed
; via this first label. Lookup table for the Jetman sprite GFX addresses.
@label=sprite_lookup_tables
@label=jetman_sprite_table
w$76c5 defw $7761    ; fly right 1
 $76c7 defw $7794    ; fly right 2
 $76c9 defw $77df    ; fly right 3
 $76cb defw $782a    ; fly right 4
 $76cd defw $7926    ; fly left 4
 $76cf defw $78db    ; fly left 3
 $76d1 defw $78a8    ; fly left 2
 $76d3 defw $7875    ; fly left 1
 $76d5 defw $7a6d    ; walk right 1
 $76d7 defw $7aa0    ; walk right 2
 $76d9 defw $7ad3    ; walk right 3
 $76db defw $7b1e    ; walk right 4
 $76dd defw $7a22    ; walk left 4
 $76df defw $79d7    ; walk left 3
 $76e1 defw $79a4    ; walk left 2
 $76e3 defw $7971    ; walk left 1

; Lookup table for the alien sprites buffer addresses.
@label=buffers_aliens_lookup_table
w$76e5 defw $5e00    ; right facing, anim frame 1
 $76e7 defw $5e00    ; right facing, anim frame 1
 $76e9 defw $5e33    ; right facing, anim frame 2
 $76eb defw $5e33    ; right facing, anim frame 2
 $76ed defw $5e99    ; left facing,  anim frame 2
 $76ef defw $5e99    ; left facing,  anim frame 2
 $76f1 defw $5e66    ; left facing,  anim frame 1
 $76f3 defw $5e66    ; left facing,  anim frame 1
; Lookup table for the item sprites buffer addresses.
@label=buffers_items_lookup_table
 $76f5 defw $5ecc    ; sprite 1
 $76f7 defw $5eff    ; sprite 2
 $76f9 defw $5f32    ; sprite 3
 $76fb defw $5f65    ; sprite 4
 $76fd defw $5f65    ; sprite 4
 $76ff defw $5f32    ; sprite 3
 $7701 defw $5eff    ; sprite 2
 $7703 defw $5ecc    ; sprite 1

; Erase sprite pixels when actor/sprite moves.
;
; Used by the routines at #R$7239, #R$7270, #R$7280 and #R$775b.
;
;  Input:B Loop counter.
;        C Actor Y position, or zero?
;        DE Address into a sprite/buffer.
;        HL Address in the DISPLAY_FILE.
; Output:BC is this the unchanged input value?
;        HL is this the unchanged input value?
@label=MaskSprite
c$7705 ld a,c        ; {Jump if vertical position is zero
 $7706 and a         ;
 $7707 jr z,$7742    ; }
 $7709 dec c         ; else decrement
 $770a push bc       ;
 $770b push hl       ;
; Loop to create a mask of the sprite and it write to the screen.
*$770c ld a,(de)     ; #REGa=sprite byte
 $770d cpl           ; {Create mask and write to screen
 $770e and (hl)      ;
 $770f ld (hl),a     ; }
 $7710 inc de        ; Next byte
 $7711 inc l         ; Next column
 $7712 ld a,l        ;
 $7713 and $1f       ;
 $7715 jr nz,$771b   ; {If column is zero, subtract 32
 $7717 ld a,l        ;
 $7718 sub $20       ;
 $771a ld l,a        ; }
*$771b djnz $770c    ; Repeat and process for next byte
 $771d pop hl        ; Restore #REGhl to be the display file address
 $771e call $72b6    ; Calculate new pixel position
 $7721 pop bc        ;
 $7722 exx           ; NOTE: what is in C' register before this swap?
 $7723 ld a,c        ; {Jump back to the top of routine if #REGc is zero
 $7724 and a         ;
 $7725 jr z,$773f    ; }
*$7727 dec c         ; else decrement (vertical position?)
 $7728 push bc       ;
 $7729 push hl       ;
; Merging sprite with current on-screen sprite (the mask?)
*$772a ld a,(de)     ; {Merge with current on-screen byte (mask?)
 $772b or (hl)       ;
 $772c ld (hl),a     ; }
 $772d inc de        ; Next sprite byte
 $772e inc l         ;
 $772f ld a,l        ; #REGa=next column number
 $7730 and $1f       ;
 $7732 jr nz,$7738   ; {Set #REGl to beginning of line if > 0 && < 32, and
 $7734 ld a,l        ; repeat process for next byte
 $7735 sub $20       ;
 $7737 ld l,a        ; }
*$7738 djnz $772a    ; Repeat and process next byte
; Calculate position for next pixel location
 $773a pop hl        ;
 $773b call $72b6    ; Calculate new pixel position
 $773e pop bc        ;
*$773f exx           ;
 $7740 jr $7705      ; Loop back to top of routine
*$7742 exx           ;
 $7743 ld a,c        ; {Jump if #REGc != 0
 $7744 and a         ;
 $7745 jr nz,$7727   ; }

; EXX then update Actor.
;
; Used by the routine at #R$7239.
@label=ActorUpdateSizeFlipReg
c$7747 exx           ;

; Update Actor height related values.
;
; Used by the routine at #R$7239.
@label=ActorUpdateSize
@ssub=ld a,($5dc0+$05) ; Actor current sprite height
c$7748 ld a,($5dc5)  ;
 $774b ld c,a        ;
@ssub=ld a,($5dc0+$06) ; Actor sprite height
 $774c ld a,($5dc6)  ;
 $774f or c          ; Compare actor sprite height values
 $7750 ret z         ; Return if both are zero
 $7751 xor a         ;
@ssub=ld ($5dc0+$05),a ; Actor current sprite height = $00
 $7752 ld ($5dc5),a  ;
 $7755 exx           ;
@ssub=ld a,($5dc0+$06) ; Actor sprite height
 $7756 ld a,($5dc6)  ;
 $7759 ld c,a        ;
 $775a xor a         ;

; Update Actor sprite height, then mask the sprite.
;
; Used by the routine at #R$7239.
@label=ActorUpdateHeightAndMask
@ssub=ld ($5dc0+$06),a ; Update Actor sprite height
c$775b ld ($5dc6),a  ;
 $775e exx           ;
 $775f jr $7705      ; Mask sprite pixels

; Actor/Collectible sprites start with a 3-byte header.
;
; +----------+--------------------+
; | Bytes(n) | Definition         |
; +----------+--------------------+
; | 0        | X position offset? |
; | 1        | Width (tiles)      |
; | 2        | Height (pixels)    |
; | 3...     | Pixel data         |
; +----------+--------------------+

; Jetman sprite for flying right #1.
@label=gfx_jetman_fly_right1
b$7761 defb $00                             ; Header byte
 $7762 defb $02,$18                         ; Width (tiles), Height (pixels)
 $7764 defb $10,$00,$20,$00,$d8,$00,$44,$00 ; Pixel data follows
 $776c defb $38,$00,$50,$1e,$00,$1c,$7c,$00
 $7774 defb $54,$18,$29,$f8,$3d,$f8,$7b,$80
 $777c defb $5b,$c0,$74,$3e,$54,$d0,$74,$d0
 $7784 defb $57,$80,$60,$00,$67,$c0,$2e,$e0
 $778c defb $2e,$e0,$2d,$e0,$0e,$00,$07,$80

; Jetman sprite for flying right #2.
@label=gfx_jetman_fly_right2
b$7794 defb $00
 $7795 defb $03,$18
 $7797 defb $0a,$00,$00,$50,$00,$00,$05,$00
 $779f defb $00,$0a,$00,$00,$08,$80,$00,$15
 $77a7 defb $07,$80,$00,$07,$00,$1f,$00,$00
 $77af defb $15,$06,$00,$0a,$7e,$00,$0f,$7e
 $77b7 defb $00,$1e,$e0,$00,$16,$f0,$00,$1d
 $77bf defb $0f,$80,$15,$34,$00,$1d,$34,$00
 $77c7 defb $15,$e0,$00,$18,$00,$00,$19,$f0
 $77cf defb $00,$0b,$b8,$00,$0b,$b8,$00,$0b
 $77d7 defb $78,$00,$03,$80,$00,$01,$e0,$00

; Jetman sprite for flying right #3.
@label=gfx_jetman_fly_right3
b$77df defb $00
 $77e0 defb $03,$18
 $77e2 defb $01,$00,$00,$04,$00,$00,$10,$80
 $77ea defb $00,$06,$00,$00,$00,$80,$00,$06
 $77f2 defb $c1,$e0,$00,$01,$c0,$07,$c0,$00
 $77fa defb $05,$41,$80,$02,$9f,$80,$03,$df
 $7802 defb $80,$07,$b8,$00,$05,$bc,$00,$07
 $780a defb $43,$e0,$05,$4d,$00,$07,$4d,$00
 $7812 defb $05,$78,$00,$06,$00,$00,$06,$7c
 $781a defb $00,$02,$ee,$00,$02,$ee,$00,$02
 $7822 defb $de,$00,$00,$e0,$00,$00,$78,$00

; Jetman sprite for flying right #4.
@label=gfx_jetman_fly_right4
b$782a defb $00
 $782b defb $03,$18
 $782d defb $08,$00,$00,$00,$80,$00,$09,$20
 $7835 defb $00,$02,$40,$00,$00,$90,$00,$02
 $783d defb $d0,$78,$00,$00,$70,$01,$f0,$00
 $7845 defb $01,$50,$60,$00,$a7,$e0,$00,$f7
 $784d defb $e0,$01,$ee,$00,$01,$6f,$00,$01
 $7855 defb $d0,$f8,$01,$53,$40,$01,$d3,$40
 $785d defb $01,$5e,$00,$01,$80,$00,$01,$9f
 $7865 defb $00,$00,$bb,$80,$00,$bb,$80,$00
 $786d defb $b7,$80,$00,$38,$00,$00,$1e,$00

; Jetman sprite for flying left #1.
@label=gfx_jetman_fly_left1
b$7875 defb $08
 $7876 defb $02,$18
 $7878 defb $00,$08,$00,$04,$00,$1b,$00,$22
 $7880 defb $00,$1c,$78,$0a,$38,$00,$00,$3e
 $7888 defb $18,$2a,$1f,$94,$1f,$bc,$01,$de
 $7890 defb $03,$da,$7c,$2e,$0b,$2a,$0b,$2e
 $7898 defb $01,$ea,$00,$06,$03,$e6,$07,$74
 $78a0 defb $07,$74,$07,$b4,$00,$70,$01,$e0

; Jetman sprite for flying left #2.
@label=gfx_jetman_fly_left2
b$78a8 defb $08
 $78a9 defb $02,$18
 $78ab defb $00,$50,$00,$0a,$00,$a0,$00,$50
 $78b3 defb $01,$10,$e0,$a8,$e0,$00,$00,$f8
 $78bb defb $60,$a8,$7e,$50,$7e,$f0,$07,$78
 $78c3 defb $0f,$68,$f0,$b8,$2c,$a8,$2c,$b8
 $78cb defb $07,$a8,$00,$18,$0f,$98,$1d,$d0
 $78d3 defb $1d,$d0,$1e,$d0,$01,$c0,$07,$80

; Jetman sprite for flying left #3.
@label=gfx_jetman_fly_left3
b$78db defb $00
 $78dc defb $03,$18
 $78de defb $00,$00,$80,$00,$00,$20,$00,$01
 $78e6 defb $08,$00,$00,$60,$00,$01,$00,$07
 $78ee defb $83,$60,$03,$80,$00,$00,$03,$e0
 $78f6 defb $01,$82,$a0,$01,$f9,$40,$01,$fb
 $78fe defb $c0,$00,$1d,$e0,$00,$3d,$a0,$07
 $7906 defb $c2,$e0,$00,$b2,$a0,$00,$b2,$e0
 $790e defb $00,$1e,$a0,$00,$00,$60,$00,$3e
 $7916 defb $60,$00,$77,$40,$00,$77,$40,$00
 $791e defb $7b,$40,$00,$07,$00,$00,$1e,$00

; Jetman sprite for flying left #4.
@label=gfx_jetman_fly_left4
b$7926 defb $00
 $7927 defb $03,$18
 $7929 defb $00,$00,$10,$00,$01,$00,$00,$04
 $7931 defb $90,$00,$02,$40,$00,$09,$00,$1e
 $7939 defb $0b,$40,$0e,$00,$00,$00,$0f,$80
 $7941 defb $06,$0a,$80,$07,$e5,$00,$07,$ef
 $7949 defb $00,$00,$77,$80,$00,$f6,$80,$1f
 $7951 defb $0b,$80,$02,$ca,$80,$02,$cb,$80
 $7959 defb $00,$7a,$80,$00,$01,$80,$00,$f9
 $7961 defb $80,$01,$dd,$00,$01,$dd,$00,$01
 $7969 defb $ed,$00,$00,$1c,$00,$00,$78,$00

; Jetman sprite for walking left #1.
@label=gfx_jetman_walk_left1
b$7971 defb $08
 $7972 defb $02,$18
 $7974 defb $00,$00,$00,$00,$07,$80,$03,$80
 $797c defb $01,$80,$00,$00,$01,$80,$03,$be
 $7984 defb $03,$aa,$03,$d4,$03,$fc,$03,$be
 $798c defb $03,$da,$7c,$2e,$0b,$2a,$0b,$2e
 $7994 defb $01,$ea,$00,$06,$03,$e6,$07,$74
 $799c defb $07,$74,$07,$b4,$00,$70,$01,$e0

; Jetman sprite for walking left #2.
@label=gfx_jetman_walk_left2
b$79a4 defb $08
 $79a5 defb $02,$18
 $79a7 defb $00,$00,$00,$00,$7f,$80,$3b,$80
 $79af defb $19,$80,$0b,$00,$17,$00,$0e,$f8
 $79b7 defb $0e,$a8,$0f,$50,$0f,$f0,$0f,$e8
 $79bf defb $0f,$68,$f0,$b8,$2c,$a8,$2c,$b8
 $79c7 defb $07,$a8,$00,$18,$0f,$98,$1d,$d0
 $79cf defb $1d,$c8,$1e,$c8,$01,$c0,$07,$80

; Jetman sprite for walking left #3.
@label=gfx_jetman_walk_left3
b$79d7 defb $00
 $79d8 defb $03,$18
 $79da defb $00,$00,$00,$00,$00,$00,$07,$87
 $79e2 defb $00,$03,$83,$80,$01,$85,$80,$00
 $79ea defb $ce,$00,$00,$dc,$00,$00,$7b,$e0
 $79f2 defb $00,$7e,$a0,$00,$3d,$40,$00,$3f
 $79fa defb $c0,$00,$3d,$e0,$00,$3d,$a0,$07
 $7a02 defb $c2,$e0,$00,$b2,$a0,$00,$b2,$e0
 $7a0a defb $00,$1e,$a0,$00,$00,$60,$00,$3e
 $7a12 defb $60,$00,$77,$40,$00,$77,$40,$00
 $7a1a defb $7b,$40,$00,$07,$00,$00,$1e,$00

; Jetman sprite for walking left #4.
@label=gfx_jetman_walk_left4
b$7a22 defb $00
 $7a23 defb $03,$18
 $7a25 defb $00,$00,$00,$00,$00,$00,$07,$f8
 $7a2d defb $00,$03,$b8,$00,$01,$98,$00,$00
 $7a35 defb $b0,$00,$01,$70,$00,$00,$ef,$80
 $7a3d defb $00,$ea,$80,$00,$f5,$00,$00,$ff
 $7a45 defb $00,$00,$f7,$80,$00,$f6,$80,$1f
 $7a4d defb $0b,$80,$02,$ca,$80,$02,$cb,$80
 $7a55 defb $00,$7a,$80,$00,$01,$80,$00,$f1
 $7a5d defb $80,$01,$dc,$80,$01,$dc,$80,$01
 $7a65 defb $ec,$80,$00,$1c,$00,$00,$78,$00

; Jetman sprite for walking right #1.
@label=gfx_jetman_walk_right1
b$7a6d defb $00
 $7a6e defb $02,$18
 $7a70 defb $00,$00,$00,$00,$01,$e0,$01,$c0
 $7a78 defb $01,$80,$00,$00,$01,$80,$7d,$c0
 $7a80 defb $55,$c0,$2b,$c0,$3f,$c0,$7b,$c0
 $7a88 defb $5b,$c0,$74,$3e,$54,$d0,$74,$d0
 $7a90 defb $57,$80,$60,$00,$67,$c0,$2e,$e0
 $7a98 defb $2e,$e0,$2d,$e0,$0e,$00,$07,$80

; Jetman sprite for walking right #2.
@label=gfx_jetman_walk_right2
b$7aa0 defb $00
 $7aa1 defb $02,$18
 $7aa3 defb $00,$00,$00,$00,$01,$fe,$01,$dc
 $7aab defb $01,$98,$00,$d0,$00,$e8,$1f,$70
 $7ab3 defb $15,$70,$0a,$f0,$0f,$f0,$1e,$f0
 $7abb defb $16,$f0,$1d,$0f,$15,$34,$1d,$34
 $7ac3 defb $15,$e0,$18,$00,$19,$f0,$0b,$b8
 $7acb defb $13,$b8,$13,$78,$03,$80,$01,$e0

; Jetman sprite for walking right #3.
@label=gfx_jetman_walk_right3
b$7ad3 defb $00
 $7ad4 defb $03,$18
 $7ad6 defb $00,$00,$00,$00,$00,$00,$00,$e1
 $7ade defb $e0,$01,$c1,$c0,$01,$a1,$80,$00
 $7ae6 defb $73,$00,$00,$3b,$00,$07,$de,$00
 $7aee defb $05,$7e,$00,$02,$bc,$00,$03,$fc
 $7af6 defb $00,$07,$bc,$00,$05,$bc,$00,$07
 $7afe defb $43,$e0,$05,$4d,$00,$07,$4d,$00
 $7b06 defb $05,$78,$00,$06,$00,$00,$06,$7c
 $7b0e defb $00,$02,$ee,$00,$02,$ee,$00,$02
 $7b16 defb $de,$00,$00,$e0,$00,$00,$78,$00

; Jetman sprite for walking right #4.
@label=gfx_jetman_walk_right4
b$7b1e defb $00
 $7b1f defb $03,$18
 $7b21 defb $00,$00,$00,$00,$00,$00,$00,$1f
 $7b29 defb $e0,$00,$1d,$c0,$00,$19,$80,$00
 $7b31 defb $0d,$00,$00,$0e,$80,$01,$f7,$00
 $7b39 defb $01,$57,$00,$00,$af,$00,$00,$ff
 $7b41 defb $00,$01,$ef,$00,$01,$6f,$00,$01
 $7b49 defb $d0,$f8,$01,$53,$40,$01,$d3,$40
 $7b51 defb $01,$5e,$00,$01,$80,$00,$01,$8f
 $7b59 defb $00,$01,$3b,$80,$01,$3b,$80,$01
 $7b61 defb $37,$80,$00,$38,$00,$00,$1e,$00

; Meteor sprite #1.
@label=gfx_meteor1
b$7b69 defb $0b
 $7b6a defb $02,$f8,$02,$ec,$51,$8e,$27,$e3
 $7b72 defb $93,$f9,$ef,$e3,$27,$9d,$5b,$c2
 $7b7a defb $25,$f4,$01,$78,$08,$10

; Meteor sprite #2.
@label=gfx_meteor2
b$7b80 defb $0b
 $7b81 defb $04,$78,$02,$8c,$25,$a6,$17,$df
 $7b89 defb $c3,$e3,$5b,$8f,$16,$3f,$4d,$9a
 $7b91 defb $01,$e4,$04,$70,$00,$90

; Explosion sprite: BIG.
@label=gfx_explosion_big
b$7b97 defb $00
 $7b98 defb $03,$10
 $7b9a defb $01,$f0,$00,$07,$f8,$86,$0f,$fe
 $7ba2 defb $f0,$6b,$fe,$f8,$fc,$ff,$fc,$ff
 $7baa defb $7f,$78,$ff,$be,$e4,$ff,$7e,$5e
 $7bb2 defb $7e,$f9,$bf,$7b,$ff,$df,$dd,$fe
 $7bba defb $ff,$3f,$ef,$be,$6f,$ef,$c4,$67
 $7bc2 defb $d3,$f8,$3b,$9c,$e0,$0f,$0e,$c0

; Explosion sprite: MEDIUM.
@label=gfx_explosion_medium
b$7bca defb $00
 $7bcb defb $03,$10
 $7bcd defb $00,$00,$00,$00,$00,$00,$00,$7c
 $7bd5 defb $00,$00,$e6,$00,$0e,$fe,$c0,$1f
 $7bdd defb $7f,$e0,$1f,$bf,$c0,$1f,$d7,$f8
 $7be5 defb $0f,$ef,$fc,$1f,$ef,$ec,$17,$df
 $7bed defb $bc,$1e,$ff,$d8,$09,$bf,$c0,$07
 $7bf5 defb $1f,$80,$00,$00,$00,$00,$00,$00

; Explosion sprite: SMALL.
@label=gfx_explosion_small
b$7bfd defb $00
 $7bfe defb $03,$10
 $7c00 defb $00,$00,$00,$00,$00,$00,$00,$00
 $7c08 defb $00,$00,$00,$00,$00,$0c,$00,$01
 $7c10 defb $de,$c0,$03,$df,$c0,$03,$ef,$c0
 $7c18 defb $03,$ac,$70,$03,$df,$f8,$01,$ff
 $7c20 defb $f8,$00,$2f,$b0,$00,$33,$00,$00
 $7c28 defb $0e,$00,$00,$00,$00,$00,$00,$00

; U3 Rocket ship sprite: bottom.
@label=gfx_rocket_u3_bottom
b$7c30 defb $00
 $7c31 defb $02,$10
 $7c33 defb $9e,$4f,$9e,$4f,$9e,$4f,$82,$41
 $7c3b defb $5c,$2e,$5c,$2e,$28,$14,$7f,$fe
 $7c43 defb $45,$fe,$45,$fe,$45,$fe,$45,$fe
 $7c4b defb $7f,$fe,$a6,$65,$a6,$65,$d9,$98

; U3 Rocket ship sprite: middle.
@label=gfx_rocket_u3_middle
b$7c53 defb $00
 $7c54 defb $02,$10
 $7c56 defb $d9,$9b,$ff,$ff,$8b,$ff,$8a,$11
 $7c5e defb $8a,$dd,$8a,$d1,$8a,$dd,$8a,$d1
 $7c66 defb $8b,$ff,$8b,$ff,$ff,$ff,$a6,$65
 $7c6e defb $a6,$65,$d9,$9b,$d9,$9b,$7f,$fe

; U3 Rocket ship sprite: top.
@label=gfx_rocket_u3_top
b$7c76 defb $00
 $7c77 defb $02,$10
 $7c79 defb $4b,$fe,$25,$fc,$25,$fc,$13,$f8
 $7c81 defb $1e,$08,$09,$f0,$09,$f0,$09,$f0
 $7c89 defb $08,$10,$05,$e0,$02,$40,$01,$80
 $7c91 defb $01,$80,$01,$80,$01,$80,$01,$80

; U1 Rocket ship sprite: bottom.
@label=gfx_rocket_u1_bottom
b$7c99 defb $00
 $7c9a defb $02,$10
 $7c9c defb $b8,$17,$b8,$17,$b9,$97,$89,$91
 $7ca4 defb $52,$ca,$55,$ea,$f5,$ef,$f4,$2f
 $7cac defb $af,$f5,$a9,$f5,$a9,$f5,$f9,$ff
 $7cb4 defb $b9,$f7,$b9,$f7,$b9,$f7,$b9,$f7

; U1 Rocket ship sprite: middle.
@label=gfx_rocket_u1_middle
b$7cbc defb $00
 $7cbd defb $02,$10
 $7cbf defb $b9,$f7,$b9,$f7,$b9,$f7,$b9,$f7
 $7cc7 defb $89,$f1,$59,$f6,$59,$f6,$29,$f4
 $7ccf defb $29,$fc,$19,$f8,$19,$18,$09,$b0
 $7cd7 defb $09,$30,$09,$b0,$09,$f0,$09,$10

; U1 Rocket ship sprite: top.
@label=gfx_rocket_u1_top
b$7cdf defb $00
 $7ce0 defb $02,$10
 $7ce2 defb $09,$50,$09,$50,$09,$50,$09,$f0
 $7cea defb $09,$f0,$09,$f0,$09,$f0,$09,$f0
 $7cf2 defb $08,$10,$09,$f0,$05,$e0,$05,$e0
 $7cfa defb $02,$c0,$02,$c0,$01,$80,$01,$80

; U5 Rocket ship sprite: bottom.
@label=gfx_rocket_u5_bottom
b$7d02 defb $00
 $7d03 defb $02,$10
 $7d05 defb $80,$4f,$80,$4f,$c0,$4f,$df,$4f
 $7d0d defb $d7,$4f,$d7,$4f,$d7,$21,$d7,$2e
 $7d15 defb $d7,$a2,$57,$9c,$57,$fe,$37,$7e
 $7d1d defb $37,$76,$1b,$76,$0b,$76,$0d,$76

; U5 Rocket ship sprite: middle.
@label=gfx_rocket_u5_middle
b$7d25 defb $00
 $7d26 defb $02,$10
 $7d28 defb $0b,$76,$0c,$7c,$0f,$f6,$0f,$f6
 $7d30 defb $0b,$16,$0b,$76,$0b,$16,$0b,$d6
 $7d38 defb $0d,$16,$0b,$f6,$0b,$f6,$0b,$16
 $7d40 defb $0b,$56,$0d,$52,$0b,$5a,$0b,$5a

; U5 Rocket ship sprite: top.
@label=gfx_rocket_u5_top
b$7d48 defb $00
 $7d49 defb $02,$10
 $7d4b defb $0b,$fa,$0b,$fa,$0f,$fa,$0f,$fa
 $7d53 defb $0c,$fa,$0c,$fa,$07,$f2,$04,$f2
 $7d5b defb $04,$f2,$03,$f2,$01,$f2,$01,$f2
 $7d63 defb $00,$f2,$00,$f2,$00,$7c,$00,$38

; U4 Rocket ship sprite: bottom.
@label=gfx_rocket_u4_bottom
b$7d6b defb $00
 $7d6c defb $02,$10
 $7d6e defb $80,$01,$89,$f1,$89,$f1,$c9,$f3
 $7d76 defb $c8,$13,$e5,$e7,$e5,$e7,$f2,$4f
 $7d7e defb $f3,$cf,$fb,$dd,$8b,$d1,$ab,$d5
 $7d86 defb $ab,$df,$ab,$d7,$fb,$df,$bb,$dd

; U4 Rocket ship sprite: middle.
@label=gfx_rocket_u4_middle
b$7d8e defb $00
 $7d8f defb $02,$10
 $7d91 defb $bb,$dd,$bb,$dd,$97,$e9,$97,$e9
 $7d99 defb $97,$e9,$8f,$f1,$8f,$f1,$8f,$f1
 $7da1 defb $0f,$f0,$1f,$f8,$1f,$f8,$1f,$f8
 $7da9 defb $1d,$b8,$19,$98,$11,$88,$19,$88

; U4 Rocket ship sprite: top.
@label=gfx_rocket_u4_top
b$7db1 defb $00
 $7db2 defb $02,$10
 $7db4 defb $15,$88,$13,$88,$19,$88,$15,$88
 $7dbc defb $1b,$98,$09,$90,$09,$90,$0d,$b0
 $7dc4 defb $05,$a0,$05,$a0,$07,$e0,$03,$c0
 $7dcc defb $03,$c0,$03,$c0,$01,$80,$01,$80

; Gold bar collectible sprite.
@label=gfx_gold_bar
b$7dd4 defb $00
 $7dd5 defb $02,$08
 $7dd7 defb $ff,$fc,$80,$0e,$40,$1e,$40,$1f
 $7ddf defb $20,$3f,$3f,$de,$1f,$ec,$0f,$f8

; Fuel pod sprite.
@label=gfx_fuel_pod
b$7de7 defb $00
 $7de8 defb $02,$0b
 $7dea defb $18,$18,$ff,$ff,$ff,$ff,$b8,$89
 $7df2 defb $ba,$bb,$8a,$9b,$ba,$bb,$8a,$8b
 $7dfa defb $ff,$ff,$ff,$ff,$18,$18

; Radiation collectible sprite.
@label=gfx_radiation
b$7e00 defb $00
 $7e01 defb $02,$0b
 $7e03 defb $0f,$f8,$10,$04,$23,$e2,$41,$c1
 $7e0b defb $60,$83,$20,$82,$6f,$7b,$4e,$39
 $7e13 defb $24,$12,$10,$04,$0f,$f8

; Chemical weapon collectible sprite.
@label=gfx_chemical_weapon
b$7e19 defb $00
 $7e1a defb $02,$0d
 $7e1c defb $70,$1c,$f8,$3e,$bf,$ee,$98,$26
 $7e24 defb $70,$1c,$20,$08,$10,$10,$10,$10
 $7e2c defb $0b,$a0,$0f,$e0,$05,$c0,$04,$c0
 $7e34 defb $03,$80

; Plutonium collectible sprite.
@label=gfx_plutonium
b$7e36 defb $00
 $7e37 defb $02,$09
 $7e39 defb $3f,$fc,$7f,$fe,$ff,$ff,$cf,$ff
 $7e41 defb $c7,$ff,$c3,$ff,$60,$7e,$38,$3c
 $7e49 defb $0f,$f0

; Diamond collectible sprite.
@label=gfx_diamond
b$7e4b defb $00
 $7e4c defb $02,$0c
 $7e4e defb $01,$80,$03,$c0,$07,$e0,$0f,$f0
 $7e56 defb $1f,$f8,$38,$1c,$68,$16,$47,$e2
 $7e5e defb $2f,$f4,$1f,$f8,$0f,$f0,$03,$c0

; Alien sprites start with a 1-byte header, and are always 16 pixels wide.
;
; +----------+-----------------+
; | Bytes(n) | Definition      |
; +----------+-----------------+
; | 0        | Height (pixels) |
; | 1...     | Pixel data      |
; +----------+-----------------+

; Squidgy Alien sprite #1.
@label=gfx_squidgy_alien1
b$7e66 defb $0e                             ; Height (pixels)
 $7e67 defb $12,$40,$1a,$94,$6b,$ea,$5f,$ff ; Pixel data follows
 $7e6f defb $3f,$fe,$f9,$9f,$36,$6c,$f6,$6e
 $7e77 defb $79,$9f,$3f,$fe,$4f,$fd,$0f,$f4
 $7e7f defb $16,$e8,$0a,$44

; Squidgy Alien sprite #2.
@label=gfx_squidgy_alien2
b$7e83 defb $0e
 $7e84 defb $0a,$44,$16,$e8,$0f,$f4,$4d,$fd
 $7e8c defb $3f,$fe,$79,$9f,$f6,$6e,$36,$6c
 $7e94 defb $f9,$9f,$3f,$fe,$5f,$ff,$6b,$ea
 $7e9c defb $1a,$94,$12,$40

; Jet Plane sprite.
@label=gfx_jet_fighter
b$7ea0 defb $07
 $7ea1 defb $1f,$f0,$c7,$80,$fb,$df,$ff,$ec
 $7ea9 defb $cf,$f0,$1e,$00,$78,$00

; Flying Saucer sprite.
@label=gfx_ufo
b$7eaf defb $08
 $7eb0 defb $3f,$fc,$7f,$fe,$d9,$9b,$7f,$fe
 $7eb8 defb $3f,$fc,$0d,$b0,$07,$e0,$01,$80

; Sphere alien sprite #1.
@label=gfx_sphere_alien1
b$7ec0 defb $10
 $7ec1 defb $07,$e0,$1f,$f8,$3f,$fc,$7f,$fe
 $7ec9 defb $7f,$fe,$ff,$ff,$ff,$ff,$ff,$ff
 $7ed1 defb $e7,$ff,$e7,$ff,$e3,$ff,$71,$fe
 $7ed9 defb $79,$fe,$3f,$fc,$1f,$f8,$07,$e0

; Sphere alien sprite #2.
@label=gfx_sphere_alien2
b$7ee1 defb $0e
 $7ee2 defb $07,$e0,$1f,$f8,$3f,$fc,$7f,$fe
 $7eea defb $7f,$fe,$ff,$ff,$ff,$ff,$e7,$ff
 $7ef2 defb $e7,$ff,$63,$fe,$71,$fe,$39,$fc
 $7efa defb $1f,$f8,$07,$e0

; Crossed Space craft sprite.
@label=gfx_cross_ship
b$7efe defb $0f
 $7eff defb $03,$80,$05,$c0,$04,$40,$07,$c0
 $7f07 defb $04,$40,$7b,$bc,$f4,$5e,$b5,$56
 $7f0f defb $94,$52,$7b,$bc,$04,$40,$07,$c0
 $7f17 defb $05,$c0,$04,$c0,$03,$80

; Space craft sprite.
@label=gfx_space_craft
b$7f1d defb $0e
 $7f1e defb $10,$00,$1e,$00,$3f,$c0,$61,$f8
 $7f26 defb $c0,$3f,$ff,$ff,$ca,$c0,$ca,$c0
 $7f2e defb $ff,$ff,$c0,$3f,$61,$f8,$3f,$c0
 $7f36 defb $1e,$00,$10,$00

; Frog Alien sprite.
@label=gfx_frog_alien
b$7f3a defb $0e
 $7f3b defb $0c,$30,$13,$c8,$3f,$fc,$7f,$fe
 $7f43 defb $ff,$ff,$df,$ff,$df,$ff,$48,$9e
 $7f4b defb $46,$6e,$2f,$f4,$19,$98,$19,$98
 $7f53 defb $0f,$f0,$06,$60

; Rocket Flame sprite #1.
@label=gfx_rocket_flames1
b$7f57 defb $00
 $7f58 defb $02,$0f
 $7f5a defb $00,$40,$04,$88,$02,$40,$10,$90
 $7f62 defb $0b,$58,$24,$62,$53,$b4,$37,$6a
 $7f6a defb $8a,$5a,$57,$ed,$2e,$f4,$b7,$fd
 $7f72 defb $5e,$ec,$7f,$f4,$2f,$fc,$00,$00

; Rocket Flame sprite #2.
@label=gfx_rocket_flames2
b$7f7a defb $00
 $7f7b defb $02,$0f
 $7f7d defb $00,$80,$02,$00,$00,$00,$00,$20
 $7f85 defb $12,$40,$00,$00,$09,$a4,$12,$c8
 $7f8d defb $4e,$18,$15,$d2,$2a,$a9,$5b,$d4
 $7f95 defb $2d,$2e,$12,$f4,$bf,$7a,$1f,$fc

; Unused bytes.
i$7f9d

; Jetpac loading screen image
;
; #UDGTABLE
; { #SCR(1,,,,,32691,38835)(splash) | Splash screen data. }
; TABLE#
@label=loading_screen
b$7fb3 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $7fc3 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $7fd3 defb $ff,$ff,$00,$3f,$ff,$ff,$c0,$0f,$ff,$ff,$f0,$03,$ff,$ff,$fc,$00
 $7fe3 defb $0f,$ff,$ff,$c0,$00,$03,$ff,$ff,$e0,$00,$ff,$ff,$f8,$01,$ff,$ff
 $7ff3 defb $ff,$ff,$01,$1f,$ff,$ff,$88,$47,$ff,$fc,$20,$11,$ff,$ff,$fc,$80
 $8003 defb $47,$ff,$ff,$e2,$00,$bf,$ff,$ff,$c4,$23,$ff,$ff,$08,$01,$ff,$ff
 $8013 defb $ff,$ff,$00,$07,$7f,$ec,$00,$37,$ff,$ff,$ec,$00,$37,$fe,$c0,$00
 $8023 defb $37,$ff,$ff,$fc,$07,$ff,$ff,$ff,$d8,$1b,$ff,$60,$00,$01,$ff,$ff
 $8033 defb $ff,$ff,$00,$df,$ff,$e2,$00,$47,$ff,$ff,$00,$00,$47,$fe,$20,$00
 $8043 defb $47,$fe,$20,$00,$bf,$fe,$18,$ff,$c4,$23,$ff,$ff,$c0,$01,$ff,$ff
 $8053 defb $ff,$ff,$01,$1f,$ff,$84,$00,$47,$ff,$ff,$e4,$00,$47,$fe,$20,$00
 $8063 defb $47,$fe,$20,$0b,$ff,$e1,$08,$ff,$c4,$10,$ff,$ff,$f2,$01,$ff,$ff
 $8073 defb $ff,$ff,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $8083 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$ff,$ff
 $8093 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $80a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $80b3 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $80c3 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $80d3 defb $ff,$ff,$00,$df,$ff,$ff,$b0,$37,$ff,$ff,$cc,$0d,$ff,$ff,$ff,$00
 $80e3 defb $37,$ff,$ff,$e0,$00,$0f,$ff,$ff,$d8,$03,$ff,$ff,$e6,$01,$ff,$ff
 $80f3 defb $ff,$ff,$01,$1f,$ff,$ff,$88,$47,$ff,$fc,$40,$11,$ff,$ff,$fc,$80
 $8103 defb $47,$ff,$ff,$e2,$01,$3f,$ff,$ff,$c4,$23,$ff,$fe,$10,$01,$ff,$ff
 $8113 defb $ff,$ff,$00,$04,$ff,$f2,$00,$4f,$ff,$ff,$f2,$00,$4f,$ff,$20,$00
 $8123 defb $4f,$ff,$ff,$f2,$1f,$ff,$ff,$ff,$e4,$27,$ff,$90,$00,$01,$ff,$ff
 $8133 defb $ff,$ff,$01,$9f,$ff,$e2,$00,$47,$ff,$fe,$80,$00,$47,$fe,$20,$00
 $8143 defb $47,$fe,$20,$01,$3f,$fe,$28,$ff,$c4,$23,$ff,$ff,$20,$01,$ff,$ff
 $8153 defb $ff,$ff,$01,$20,$00,$04,$00,$48,$00,$00,$14,$00,$48,$01,$20,$00
 $8163 defb $48,$01,$20,$16,$00,$32,$09,$00,$24,$10,$00,$00,$0a,$01,$ff,$ff
 $8173 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8183 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8193 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $81a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $81b3 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $81c3 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $81d3 defb $ff,$ff,$01,$1f,$ff,$ff,$88,$47,$ff,$ff,$c2,$11,$ff,$ff,$fc,$80
 $81e3 defb $47,$ff,$ff,$f0,$00,$17,$ff,$ff,$c4,$07,$ff,$ff,$e1,$01,$ff,$ff
 $81f3 defb $ff,$ff,$01,$20,$ff,$f0,$48,$47,$fe,$03,$40,$12,$0f,$ff,$04,$80
 $8203 defb $47,$fe,$1f,$e2,$01,$7f,$f8,$ff,$c4,$23,$ff,$81,$10,$01,$ff,$ff
 $8213 defb $ff,$ff,$00,$07,$00,$0e,$00,$70,$00,$00,$0c,$00,$70,$00,$e0,$00
 $8223 defb $70,$00,$00,$0e,$1c,$00,$00,$00,$5c,$38,$00,$70,$00,$01,$ff,$ff
 $8233 defb $ff,$ff,$01,$1f,$ff,$e2,$00,$47,$ff,$fe,$40,$00,$47,$fe,$20,$00
 $8243 defb $47,$fe,$20,$01,$7f,$fc,$28,$ff,$c4,$23,$ff,$ff,$90,$01,$ff,$ff
 $8253 defb $ff,$ff,$01,$c0,$00,$18,$00,$70,$00,$00,$0e,$00,$70,$00,$e0,$00
 $8263 defb $70,$00,$e0,$1c,$00,$1e,$0e,$00,$1c,$0c,$00,$00,$07,$01,$ff,$ff
 $8273 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8283 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8293 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $82a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $82b3 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $82c3 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $82d3 defb $ff,$ff,$01,$1f,$ff,$ff,$88,$47,$ff,$ff,$84,$11,$ff,$ff,$fc,$80
 $82e3 defb $47,$ff,$ff,$e8,$00,$27,$ff,$ff,$c4,$0b,$ff,$ff,$c2,$01,$ff,$ff
 $82f3 defb $ff,$ff,$01,$c3,$7f,$ec,$38,$47,$fe,$00,$80,$1c,$37,$fe,$c3,$80
 $8303 defb $47,$fe,$1f,$e2,$02,$7f,$f0,$ff,$c4,$23,$ff,$60,$e0,$01,$ff,$ff
 $8313 defb $ff,$ff,$00,$04,$ff,$f2,$00,$4f,$ff,$ff,$f2,$00,$4f,$ff,$20,$00
 $8323 defb $4f,$ff,$ff,$f2,$27,$ff,$ff,$ff,$e4,$27,$ff,$90,$00,$01,$ff,$ff
 $8333 defb $ff,$ff,$01,$1f,$ff,$e2,$00,$47,$ff,$ff,$60,$00,$47,$fe,$20,$00
 $8343 defb $47,$fe,$20,$02,$7f,$fc,$48,$ff,$c4,$23,$ff,$ff,$90,$01,$ff,$ff
 $8353 defb $ff,$ff,$01,$ff,$ff,$e0,$00,$7f,$ff,$ff,$fe,$00,$7f,$ff,$e0,$00
 $8363 defb $7f,$ff,$e0,$3f,$ff,$fc,$0f,$ff,$fc,$03,$ff,$ff,$ff,$01,$ff,$ff
 $8373 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8383 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8393 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $83a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $83b3 defb $ff,$ff,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $83c3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$ff,$ff
 $83d3 defb $ff,$ff,$01,$1f,$ff,$ff,$88,$47,$ff,$ff,$04,$11,$ff,$ff,$fc,$80
 $83e3 defb $47,$ff,$ff,$e4,$00,$2f,$ff,$ff,$c4,$13,$ff,$ff,$c2,$01,$ff,$ff
 $83f3 defb $ff,$ff,$01,$fc,$7f,$e3,$f8,$47,$ff,$ff,$f0,$1f,$c7,$fe,$3f,$80
 $8403 defb $47,$ff,$ff,$e2,$02,$ff,$ff,$ff,$c4,$23,$ff,$1f,$e0,$01,$ff,$ff
 $8413 defb $ff,$ff,$00,$07,$7f,$ec,$00,$37,$ff,$ff,$ec,$00,$37,$fe,$c0,$00
 $8423 defb $37,$ff,$ff,$8c,$3f,$ff,$ff,$ff,$dc,$1b,$ff,$60,$00,$01,$ff,$ff
 $8433 defb $ff,$ff,$01,$1f,$ff,$e2,$00,$47,$ff,$ff,$20,$00,$47,$fe,$20,$00
 $8443 defb $47,$fe,$20,$02,$ff,$f8,$48,$ff,$c4,$23,$ff,$ff,$c8,$01,$ff,$ff
 $8453 defb $ff,$ff,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $8463 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$ff,$ff
 $8473 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8483 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8493 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $84a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $84b3 defb $ff,$ff,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $84c3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$ff,$ff
 $84d3 defb $ff,$ff,$01,$1f,$ff,$ff,$88,$47,$ff,$ff,$08,$11,$ff,$ff,$fc,$80
 $84e3 defb $47,$ff,$ff,$e4,$00,$4f,$ff,$ff,$c4,$13,$ff,$ff,$84,$01,$ff,$ff
 $84f3 defb $ff,$ff,$00,$04,$7f,$e2,$00,$4f,$ff,$ff,$fc,$00,$0f,$ff,$20,$00
 $8503 defb $4f,$ff,$ff,$f2,$05,$ff,$ff,$ff,$e4,$27,$ff,$90,$00,$01,$ff,$ff
 $8513 defb $ff,$ff,$00,$04,$7f,$e2,$00,$47,$fe,$00,$12,$00,$47,$fe,$20,$00
 $8523 defb $47,$ff,$00,$04,$4f,$ff,$81,$ff,$c4,$23,$ff,$10,$00,$01,$ff,$ff
 $8533 defb $ff,$ff,$01,$1f,$ff,$e2,$00,$47,$ff,$ff,$90,$00,$47,$fe,$20,$00
 $8543 defb $47,$fe,$20,$04,$ff,$f8,$88,$ff,$c4,$23,$ff,$ff,$c8,$01,$ff,$ff
 $8553 defb $ff,$ff,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $8563 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$ff,$ff
 $8573 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8583 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8593 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $85a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $85b3 defb $ff,$ff,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $85c3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$ff,$ff
 $85d3 defb $ff,$ff,$01,$1f,$ff,$ff,$88,$47,$ff,$fe,$10,$11,$ff,$ff,$fc,$80
 $85e3 defb $47,$ff,$ff,$e2,$00,$5f,$ff,$ff,$c4,$23,$ff,$ff,$84,$01,$ff,$ff
 $85f3 defb $ff,$ff,$00,$04,$00,$02,$00,$70,$00,$00,$0e,$00,$30,$00,$e0,$00
 $8603 defb $70,$00,$00,$0e,$06,$00,$00,$00,$1c,$38,$00,$70,$00,$01,$ff,$ff
 $8613 defb $ff,$ff,$00,$04,$7f,$e2,$00,$47,$fe,$00,$0e,$00,$47,$fe,$20,$00
 $8623 defb $47,$fe,$c0,$18,$5f,$ff,$67,$ff,$c4,$23,$ff,$10,$00,$01,$ff,$ff
 $8633 defb $ff,$ff,$01,$1f,$ff,$e2,$00,$47,$ff,$ff,$d0,$00,$47,$fe,$20,$00
 $8643 defb $47,$fe,$20,$05,$ff,$f0,$88,$ff,$c4,$23,$ff,$ff,$e4,$01,$ff,$ff
 $8653 defb $ff,$ff,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $8663 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$ff,$ff
 $8673 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8683 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8693 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $86a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $86b3 defb $ff,$ff,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $86c3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$ff,$ff
 $86d3 defb $ff,$ff,$01,$1f,$ff,$ff,$88,$47,$ff,$fc,$10,$11,$ff,$ff,$fc,$80
 $86e3 defb $47,$ff,$ff,$e2,$00,$9f,$ff,$ff,$c4,$23,$ff,$ff,$08,$01,$ff,$ff
 $86f3 defb $ff,$ff,$00,$04,$ff,$f2,$00,$4f,$ff,$ff,$f2,$00,$4f,$ff,$20,$00
 $8703 defb $4f,$ff,$ff,$f2,$09,$ff,$ff,$ff,$e4,$27,$ff,$90,$00,$01,$ff,$ff
 $8713 defb $ff,$ff,$00,$3f,$ff,$e2,$00,$47,$ff,$ff,$fe,$00,$47,$fe,$20,$00
 $8723 defb $47,$fe,$3f,$e0,$9f,$ff,$18,$ff,$c4,$23,$ff,$ff,$00,$01,$ff,$ff
 $8733 defb $ff,$ff,$01,$1f,$ff,$c2,$00,$47,$ff,$ff,$c8,$00,$47,$fe,$20,$00
 $8743 defb $47,$fe,$20,$09,$ff,$f1,$08,$ff,$c4,$21,$ff,$ff,$f4,$01,$ff,$ff
 $8753 defb $ff,$ff,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $8763 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$ff,$ff
 $8773 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8783 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8793 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $87a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $87b3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $87c3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$3c,$00
 $87d3 defb $f0,$00,$00,$08,$9f,$00,$00,$04,$e8,$00,$c2,$00,$00,$00,$00,$00
 $87e3 defb $00,$40,$00,$00,$17,$37,$df,$81,$0e,$00,$00,$7e,$00,$00,$00,$00
 $87f3 defb $33,$00,$13,$c1,$9f,$70,$3c,$00,$00,$00,$c1,$c0,$00,$00,$00,$00
 $8803 defb $00,$00,$00,$00,$fd,$51,$b2,$de,$bb,$d0,$00,$07,$0e,$0b,$f0,$00
 $8813 defb $0c,$78,$04,$04,$18,$20,$e0,$6c,$00,$30,$48,$78,$00,$01,$30,$00
 $8823 defb $00,$57,$03,$e0,$0f,$1f,$ff,$bc,$f7,$f7,$70,$01,$ff,$07,$0b,$8c
 $8833 defb $01,$00,$61,$e4,$07,$81,$83,$c0,$00,$60,$07,$03,$fe,$9a,$28,$ee
 $8843 defb $00,$37,$c7,$ff,$c0,$78,$30,$88,$e3,$bf,$77,$80,$00,$3f,$c0,$f3
 $8853 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8863 defb $f6,$93,$fe,$90,$90,$02,$01,$ea,$26,$77,$ee,$3e,$80,$07,$cc,$fc
 $8873 defb $03,$e0,$ce,$0c,$00,$80,$c0,$00,$8c,$00,$7c,$40,$e0,$7c,$10,$03
 $8883 defb $f8,$07,$fc,$0f,$f0,$07,$fc,$ff,$e3,$80,$31,$ea,$00,$00,$02,$31
 $8893 defb $03,$03,$c0,$3e,$00,$70,$61,$e0,$7e,$06,$00,$06,$00,$1c,$0f,$f2
 $88a3 defb $0b,$98,$01,$c7,$e7,$18,$03,$f0,$78,$9f,$11,$7a,$5e,$a0,$00,$03
 $88b3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$08,$00,$00,$00
 $88c3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$42,$00
 $88d3 defb $f0,$00,$00,$09,$bb,$00,$00,$00,$40,$00,$40,$00,$00,$00,$00,$00
 $88e3 defb $00,$00,$00,$00,$26,$0b,$bf,$86,$f1,$00,$01,$fe,$00,$00,$00,$00
 $88f3 defb $33,$80,$23,$c8,$8f,$e0,$3e,$00,$00,$03,$f2,$c0,$00,$00,$00,$00
 $8903 defb $00,$00,$00,$00,$9c,$89,$bd,$5e,$bb,$e8,$00,$03,$8c,$18,$78,$60
 $8913 defb $02,$38,$04,$08,$18,$10,$f0,$6e,$00,$50,$98,$78,$00,$02,$1c,$00
 $8923 defb $00,$cf,$87,$80,$3b,$ff,$c0,$79,$eb,$f7,$b8,$00,$6b,$83,$85,$8e
 $8933 defb $01,$00,$c3,$76,$0f,$c0,$80,$60,$01,$c0,$03,$80,$7f,$b6,$51,$c7
 $8943 defb $03,$ff,$c4,$9f,$ff,$fa,$08,$88,$c9,$bf,$7b,$40,$00,$1f,$e0,$7b
 $8953 defb $00,$07,$07,$b4,$00,$1c,$00,$63,$8c,$06,$00,$70,$01,$c1,$e3,$80
 $8963 defb $27,$bf,$ff,$61,$00,$02,$03,$d9,$23,$ef,$ec,$3e,$80,$06,$e6,$bc
 $8973 defb $07,$82,$fe,$0c,$00,$40,$e0,$00,$c3,$00,$1e,$20,$70,$3f,$0c,$01
 $8983 defb $fc,$02,$ab,$ff,$ff,$f8,$01,$ff,$82,$00,$cd,$f2,$00,$00,$00,$38
 $8993 defb $02,$03,$c0,$3f,$00,$78,$20,$f0,$7f,$01,$80,$0f,$80,$06,$1c,$7d
 $89a3 defb $85,$f0,$02,$38,$18,$06,$1c,$00,$f8,$df,$39,$74,$3f,$84,$00,$01
 $89b3 defb $00,$00,$10,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $89c3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$99,$00
 $89d3 defb $d8,$00,$00,$11,$ad,$80,$00,$00,$10,$00,$28,$00,$00,$00,$00,$00
 $89e3 defb $00,$00,$00,$00,$4e,$06,$ef,$89,$ef,$00,$01,$ef,$80,$00,$00,$00
 $89f3 defb $63,$c0,$5b,$88,$47,$70,$3f,$00,$00,$02,$74,$e0,$00,$00,$00,$00
 $8a03 defb $02,$00,$00,$00,$9d,$06,$b3,$d9,$fb,$ec,$00,$03,$f0,$18,$7d,$e0
 $8a13 defb $02,$30,$08,$10,$38,$11,$38,$67,$38,$f0,$9c,$7c,$00,$02,$43,$00
 $8a23 defb $00,$e8,$9f,$7f,$fd,$3d,$3f,$cd,$db,$fb,$b8,$00,$35,$e1,$c3,$e7
 $8a33 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8a43 defb $fc,$be,$04,$4f,$ff,$e9,$80,$1f,$78,$df,$b8,$20,$00,$07,$f0,$3d
 $8a53 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8a63 defb $ad,$86,$49,$98,$00,$04,$0d,$dd,$13,$df,$92,$1e,$80,$0f,$f3,$5e
 $8a73 defb $0e,$07,$8c,$0e,$00,$40,$f0,$00,$e1,$00,$1f,$10,$70,$3f,$c2,$00
 $8a83 defb $7e,$01,$b5,$ff,$ff,$ff,$ff,$ff,$19,$03,$3d,$e4,$70,$00,$00,$1c
 $8a93 defb $02,$0e,$00,$3f,$00,$3c,$20,$70,$0e,$00,$f0,$ef,$f8,$03,$8c,$0f
 $8aa3 defb $c2,$f0,$03,$e9,$e0,$01,$7c,$01,$f8,$c3,$ff,$6a,$7e,$d0,$c0,$00
 $8ab3 defb $00,$00,$00,$00,$00,$00,$00,$00,$40,$00,$00,$00,$00,$00,$00,$00
 $8ac3 defb $00,$00,$00,$00,$00,$1f,$fc,$00,$00,$44,$00,$00,$00,$10,$a1,$00
 $8ad3 defb $b8,$00,$01,$11,$ad,$c0,$10,$02,$40,$00,$00,$00,$00,$00,$00,$00
 $8ae3 defb $00,$00,$00,$00,$4e,$03,$37,$36,$1e,$80,$03,$e5,$c0,$00,$00,$00
 $8af3 defb $61,$c0,$99,$88,$41,$e0,$c7,$80,$00,$02,$38,$e0,$00,$00,$00,$00
 $8b03 defb $01,$00,$00,$00,$fe,$00,$ed,$47,$f7,$ef,$00,$01,$f8,$2c,$37,$b8
 $8b13 defb $04,$20,$08,$18,$3c,$01,$1c,$3b,$ff,$41,$2c,$76,$00,$05,$23,$c0
 $8b23 defb $00,$57,$a1,$ff,$fd,$c2,$ff,$f3,$dd,$fb,$dc,$00,$3b,$f8,$c1,$b7
 $8b33 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8b43 defb $f5,$5b,$70,$4f,$89,$c4,$c0,$11,$3c,$ef,$bc,$20,$00,$00,$f8,$0f
 $8b53 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8b63 defb $d4,$d6,$49,$c7,$ff,$f8,$33,$dc,$97,$be,$73,$1e,$80,$1e,$f3,$8e
 $8b73 defb $1c,$0e,$18,$1e,$00,$c0,$f8,$01,$f1,$80,$7e,$08,$38,$33,$e2,$80
 $8b83 defb $3f,$00,$ea,$ff,$ff,$ff,$ff,$ff,$81,$0c,$fd,$ec,$24,$00,$00,$0e
 $8b93 defb $04,$3c,$00,$ef,$80,$3e,$20,$70,$07,$00,$78,$01,$fe,$00,$e0,$0f
 $8ba3 defb $f0,$f0,$00,$16,$30,$00,$be,$03,$f8,$e3,$39,$76,$c3,$04,$08,$00
 $8bb3 defb $00,$00,$00,$00,$c0,$00,$00,$00,$00,$00,$38,$00,$00,$00,$00,$18
 $8bc3 defb $00,$00,$00,$00,$03,$ff,$fc,$03,$00,$06,$00,$08,$40,$38,$a1,$00
 $8bd3 defb $cc,$00,$03,$a1,$bd,$c3,$40,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $8be3 defb $00,$00,$00,$00,$9c,$03,$77,$db,$df,$40,$07,$ec,$70,$06,$00,$00
 $8bf3 defb $61,$e0,$a5,$10,$21,$f1,$1b,$c0,$00,$04,$30,$d0,$00,$00,$00,$00
 $8c03 defb $10,$00,$00,$01,$cc,$40,$ee,$7a,$bf,$ef,$00,$01,$f8,$2c,$36,$1c
 $8c13 defb $08,$20,$10,$0c,$3c,$02,$1e,$3d,$ef,$81,$0c,$7b,$00,$0a,$12,$c0
 $8c23 defb $00,$be,$7f,$ff,$d9,$fe,$ff,$fb,$bd,$fd,$de,$00,$2f,$f8,$20,$f9
 $8c33 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8c43 defb $ed,$2f,$c0,$4f,$b4,$60,$60,$3c,$9c,$6f,$bc,$70,$00,$00,$fe,$87
 $8c53 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8c63 defb $ff,$ee,$49,$e0,$00,$f7,$c3,$bc,$8c,$79,$92,$8e,$80,$1e,$39,$c7
 $8c73 defb $18,$1c,$f0,$1e,$00,$60,$f8,$03,$f8,$c0,$f8,$0c,$1c,$21,$f0,$c0
 $8c83 defb $3f,$06,$7f,$ff,$ff,$ff,$ff,$ff,$01,$b3,$fe,$f0,$12,$40,$00,$0f
 $8c93 defb $00,$38,$00,$7f,$80,$3d,$10,$30,$03,$c0,$78,$00,$0f,$80,$1f,$80
 $8ca3 defb $00,$38,$01,$e4,$08,$7c,$9f,$0f,$f4,$a3,$11,$f9,$1a,$b0,$90,$00
 $8cb3 defb $80,$00,$00,$01,$70,$00,$00,$02,$10,$00,$74,$00,$00,$00,$00,$18
 $8cc3 defb $00,$00,$00,$00,$06,$ff,$f6,$fc,$c0,$00,$00,$18,$00,$10,$99,$00
 $8cd3 defb $ce,$00,$05,$a1,$8c,$c4,$60,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $8ce3 defb $00,$00,$00,$00,$9c,$03,$79,$e4,$0f,$c0,$3f,$c2,$38,$1b,$80,$00
 $8cf3 defb $30,$f1,$05,$10,$20,$f1,$07,$e0,$00,$04,$30,$d0,$00,$00,$40,$00
 $8d03 defb $00,$00,$00,$1f,$ce,$a9,$f7,$ad,$bf,$ef,$c0,$01,$f8,$4c,$12,$1e
 $8d13 defb $04,$40,$10,$0c,$3c,$00,$0f,$06,$78,$12,$4c,$79,$80,$14,$11,$30
 $8d23 defb $00,$bb,$77,$1c,$c8,$fb,$f8,$17,$be,$fd,$ee,$00,$7f,$f7,$10,$dc
 $8d33 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8d43 defb $b0,$17,$f0,$0f,$92,$32,$a0,$44,$9e,$77,$dc,$78,$00,$01,$ff,$47
 $8d53 defb $00,$1c,$07,$08,$00,$01,$00,$30,$70,$00,$80,$70,$00,$e2,$40,$78
 $8d63 defb $00,$33,$ff,$ff,$ff,$f8,$07,$7e,$4d,$e6,$14,$ed,$00,$3c,$1c,$c7
 $8d73 defb $30,$18,$e0,$1e,$00,$70,$ec,$03,$fc,$61,$f0,$04,$07,$01,$f0,$20
 $8d83 defb $0b,$0f,$00,$1f,$ff,$ff,$ff,$ff,$20,$cc,$fe,$f0,$79,$00,$00,$07
 $8d93 defb $00,$30,$00,$ff,$c0,$7d,$80,$c0,$03,$20,$7c,$00,$03,$e0,$1c,$70
 $8da3 defb $00,$0c,$01,$df,$e7,$ff,$5f,$7f,$e4,$b7,$93,$df,$5b,$d4,$60,$00
 $8db3 defb $c0,$00,$00,$02,$38,$00,$00,$00,$40,$00,$c0,$00,$00,$00,$00,$00
 $8dc3 defb $00,$00,$00,$00,$0f,$3f,$ee,$30,$30,$20,$00,$3c,$08,$00,$42,$00
 $8dd3 defb $e6,$00,$09,$e1,$9e,$c8,$70,$00,$40,$00,$00,$80,$00,$00,$00,$00
 $8de3 defb $00,$00,$00,$00,$9c,$02,$fe,$de,$77,$a0,$46,$42,$3c,$13,$80,$08
 $8df3 defb $10,$fa,$02,$08,$10,$f0,$81,$f0,$00,$08,$20,$70,$00,$00,$e0,$00
 $8e03 defb $00,$1c,$00,$7e,$27,$17,$8b,$4d,$bf,$ee,$e0,$01,$fc,$24,$12,$1b
 $8e13 defb $02,$40,$20,$7c,$3e,$04,$0f,$03,$e0,$30,$8e,$7f,$e0,$65,$12,$7c
 $8e23 defb $00,$5c,$76,$0c,$24,$0f,$86,$17,$77,$7e,$ef,$00,$fd,$fe,$01,$dc
 $8e33 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8e43 defb $fa,$48,$3c,$0d,$92,$30,$28,$76,$4f,$17,$dc,$fe,$00,$01,$ff,$f0
 $8e53 defb $00,$38,$0d,$0c,$01,$00,$80,$0c,$38,$00,$d0,$80,$00,$72,$20,$1e
 $8e63 defb $00,$10,$03,$ff,$ff,$ff,$f7,$7e,$7d,$98,$0d,$65,$00,$e0,$0c,$e3
 $8e73 defb $20,$38,$e8,$1e,$00,$70,$67,$01,$f8,$39,$80,$04,$03,$81,$df,$18
 $8e83 defb $0b,$0d,$00,$40,$0f,$ff,$ff,$fc,$30,$b0,$fe,$f0,$5d,$08,$00,$07
 $8e93 defb $00,$30,$01,$f3,$c0,$7e,$10,$18,$01,$10,$7c,$00,$00,$e0,$03,$08
 $8ea3 defb $00,$04,$01,$a0,$77,$ff,$ff,$ff,$e3,$3d,$ff,$6f,$1f,$62,$74,$00
 $8eb3 defb $e0,$00,$00,$04,$9e,$00,$00,$00,$40,$00,$c0,$00,$00,$00,$00,$00
 $8ec3 defb $00,$00,$00,$00,$1f,$cf,$ef,$40,$0c,$00,$00,$7c,$00,$00,$3c,$08
 $8ed3 defb $77,$00,$13,$c1,$97,$70,$70,$00,$00,$00,$01,$80,$00,$00,$00,$00
 $8ee3 defb $00,$00,$00,$00,$9e,$23,$3e,$de,$8b,$d0,$80,$86,$0d,$cb,$60,$00
 $8ef3 defb $10,$7c,$02,$04,$18,$70,$80,$f8,$00,$10,$40,$78,$00,$01,$60,$00
 $8f03 defb $00,$3f,$00,$f8,$16,$f7,$fe,$d6,$7f,$ef,$e0,$01,$fe,$1e,$09,$1d
 $8f13 defb $00,$80,$20,$f4,$0f,$83,$03,$80,$c0,$61,$86,$3f,$f8,$9a,$2a,$ee
 $8f23 defb $00,$bf,$88,$02,$24,$3f,$c1,$0f,$e3,$7e,$f7,$80,$80,$ff,$c0,$e6
 $8f33 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $8f43 defb $ed,$24,$03,$09,$92,$10,$20,$ea,$47,$2b,$dd,$7d,$00,$00,$dd,$f8
 $8f53 defb $00,$70,$0e,$0c,$01,$00,$80,$07,$1c,$00,$78,$03,$e0,$3c,$30,$0f
 $8f63 defb $c8,$0c,$00,$00,$0f,$ff,$fa,$fe,$22,$60,$0b,$c5,$00,$80,$06,$75
 $8f73 defb $01,$f0,$60,$1e,$00,$f0,$63,$c0,$7c,$0f,$00,$06,$00,$61,$8f,$cc
 $8f83 defb $1b,$1c,$00,$3f,$10,$e7,$ff,$f8,$38,$c1,$92,$f8,$aa,$01,$00,$03
 $8f93 defb $00,$20,$10,$f3,$c0,$fc,$08,$1c,$01,$08,$fc,$00,$00,$60,$00,$07
 $8fa3 defb $00,$03,$00,$a3,$9b,$ff,$ff,$fe,$c5,$18,$fc,$3f,$a7,$f8,$96,$00
 $8fb3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $8fc3 defb $00,$00,$00,$ff,$ed,$ff,$ff,$fc,$c5,$10,$f0,$80,$1e,$ea,$21,$00
 $8fd3 defb $1c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $8fe3 defb $00,$38,$00,$5f,$0e,$7e,$00,$00,$00,$01,$01,$af,$fe,$fe,$14,$a0
 $8ff3 defb $38,$fc,$3f,$3f,$00,$3f,$01,$f9,$ff,$cf,$fe,$7c,$7c,$03,$f0,$1f
 $9003 defb $80,$1c,$00,$03,$1c,$ff,$dc,$00,$00,$00,$04,$88,$00,$06,$3d,$aa
 $9013 defb $38,$b4,$2f,$27,$00,$25,$01,$49,$29,$7a,$52,$4b,$df,$42,$70,$16
 $9023 defb $80,$1c,$3c,$00,$01,$f7,$ff,$75,$80,$00,$00,$00,$0a,$ae,$ff,$f7
 $9033 defb $38,$ff,$9e,$03,$fc,$f3,$c3,$ff,$79,$ef,$f8,$3f,$e7,$f9,$f0,$fd
 $9043 defb $ff,$1c,$00,$01,$be,$0f,$f3,$00,$00,$00,$00,$00,$00,$02,$6a,$d9
 $9053 defb $38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9063 defb $00,$1c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9073 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9083 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9093 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $90a3 defb $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $90b3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $90c3 defb $00,$00,$01,$00,$f7,$5c,$ff,$9c,$42,$dd,$c2,$23,$66,$d4,$7a,$00
 $90d3 defb $38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $90e3 defb $00,$1c,$00,$20,$39,$fe,$00,$00,$00,$00,$0a,$57,$ff,$ed,$ab,$08
 $90f3 defb $38,$f4,$3f,$3f,$00,$3f,$01,$f9,$ff,$cf,$fe,$7f,$7c,$03,$f0,$1f
 $9103 defb $80,$1c,$00,$00,$f3,$c1,$be,$00,$00,$00,$00,$23,$1a,$9b,$5f,$de
 $9113 defb $38,$be,$5f,$2f,$00,$2d,$01,$69,$69,$7a,$7a,$5f,$ff,$c2,$f0,$17
 $9123 defb $80,$1c,$42,$00,$07,$fb,$ff,$7b,$80,$00,$00,$00,$21,$71,$ff,$ff
 $9133 defb $38,$ff,$de,$07,$fe,$f3,$c3,$ff,$79,$ef,$f8,$7f,$ef,$fd,$f9,$fd
 $9143 defb $ff,$1c,$00,$00,$1d,$ef,$ef,$00,$00,$00,$00,$00,$00,$00,$85,$26
 $9153 defb $1c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9163 defb $00,$38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9173 defb $00,$00,$00,$00,$00,$00,$00,$fc,$fc,$fe,$7f,$3f,$80,$e7,$7f,$71
 $9183 defb $c0,$7e,$3e,$00,$fe,$fe,$7e,$fc,$fe,$00,$00,$00,$00,$00,$00,$00
 $9193 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $91a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $91b3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $91c3 defb $00,$00,$01,$00,$1f,$8c,$ae,$9a,$8c,$3e,$1d,$dc,$7f,$ea,$3e,$80
 $91d3 defb $38,$fc,$3f,$3f,$07,$ff,$f9,$f9,$fe,$01,$fe,$7f,$e0,$7f,$ff,$9f
 $91e3 defb $ff,$1c,$00,$1f,$e7,$fd,$80,$00,$00,$00,$31,$ce,$df,$d6,$17,$64
 $91f3 defb $38,$f4,$3d,$3d,$00,$3f,$01,$f9,$ff,$ff,$fa,$7e,$fe,$03,$d0,$1e
 $9203 defb $ff,$1c,$00,$00,$0c,$01,$67,$00,$00,$00,$02,$0d,$bf,$53,$77,$75
 $9213 defb $38,$bf,$ff,$2f,$ff,$2f,$01,$e9,$e8,$bc,$7e,$5e,$0f,$e2,$f0,$17
 $9223 defb $ff,$1c,$99,$00,$1f,$fd,$fe,$f6,$00,$00,$00,$00,$45,$af,$df,$ff
 $9233 defb $38,$f3,$de,$07,$9e,$f3,$c0,$78,$79,$ef,$00,$78,$0f,$3d,$f9,$fd
 $9243 defb $e0,$1c,$00,$00,$00,$df,$9e,$00,$00,$00,$00,$00,$00,$04,$13,$5d
 $9253 defb $1e,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9263 defb $00,$78,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9273 defb $00,$00,$00,$00,$00,$00,$00,$fe,$fe,$fc,$fe,$7f,$00,$ef,$7e,$73
 $9283 defb $c0,$7f,$7f,$01,$fc,$fe,$fe,$fe,$fe,$00,$00,$00,$00,$00,$00,$00
 $9293 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $92a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $92b3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $92c3 defb $00,$00,$01,$8f,$ff,$c4,$a1,$9a,$88,$00,$a1,$59,$ff,$bd,$5e,$00
 $92d3 defb $38,$fc,$3f,$3f,$07,$ff,$f9,$f9,$fe,$01,$fe,$7f,$e0,$7f,$ff,$9f
 $92e3 defb $ff,$1c,$00,$08,$0f,$fb,$c0,$00,$00,$00,$06,$19,$f4,$fc,$5e,$10
 $92f3 defb $38,$f4,$3d,$3d,$00,$3d,$01,$f9,$ff,$ff,$fa,$7e,$ba,$03,$d0,$1e
 $9303 defb $81,$1c,$00,$00,$04,$02,$c3,$80,$00,$00,$00,$25,$e5,$fd,$be,$f6
 $9313 defb $38,$bf,$ff,$2f,$ff,$3f,$01,$f9,$f8,$fc,$7e,$5e,$0f,$e3,$f0,$1f
 $9323 defb $ff,$1c,$a1,$00,$ff,$fe,$fe,$ee,$00,$00,$00,$00,$00,$95,$7f,$fb
 $9333 defb $38,$ff,$de,$07,$fe,$ff,$c0,$78,$7f,$ef,$e0,$7b,$ef,$fd,$ff,$fd
 $9343 defb $fc,$1c,$00,$00,$00,$1f,$70,$00,$00,$00,$00,$00,$00,$00,$21,$2a
 $9353 defb $0f,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $9363 defb $ff,$f0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9373 defb $00,$00,$00,$00,$00,$00,$00,$ee,$ee,$e0,$f0,$78,$00,$fe,$70,$3f
 $9383 defb $80,$1c,$77,$01,$e0,$38,$ee,$ee,$38,$00,$00,$00,$00,$00,$00,$00
 $9393 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $93a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $93b3 defb $01,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $93c3 defb $ff,$80,$00,$7f,$ff,$e9,$c1,$35,$30,$00,$2a,$af,$ff,$f8,$95,$20
 $93d3 defb $38,$fc,$3f,$3f,$07,$ff,$f9,$f9,$ff,$03,$fe,$7f,$f0,$7f,$ff,$9f
 $93e3 defb $ff,$1c,$00,$08,$ff,$f7,$e0,$00,$00,$00,$05,$36,$fb,$b5,$06,$a8
 $93f3 defb $38,$f4,$3d,$3d,$00,$3d,$01,$79,$7b,$ff,$fa,$7a,$5d,$02,$d0,$1e
 $9403 defb $fd,$1c,$00,$00,$03,$0d,$86,$80,$00,$00,$00,$0b,$6b,$5a,$5e,$d9
 $9413 defb $38,$5f,$fe,$3f,$ff,$3f,$01,$f9,$f8,$78,$7e,$7e,$07,$f3,$f0,$1f
 $9423 defb $ff,$1c,$a1,$01,$ff,$fd,$fe,$dc,$00,$00,$00,$00,$0c,$2f,$dd,$fe
 $9433 defb $38,$ff,$9e,$07,$fe,$7f,$c0,$78,$7f,$ef,$e0,$7b,$ef,$fd,$ff,$fd
 $9443 defb $fc,$1c,$00,$00,$00,$1c,$e0,$00,$00,$00,$00,$00,$00,$00,$04,$28
 $9453 defb $07,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $9463 defb $ff,$e0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9473 defb $00,$00,$00,$00,$00,$00,$00,$fe,$fe,$f8,$7e,$3f,$00,$fc,$7c,$1f
 $9483 defb $00,$1c,$77,$00,$fc,$39,$fe,$fe,$38,$00,$00,$00,$00,$00,$00,$00
 $9493 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $94a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $94b3 defb $07,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $94c3 defb $ff,$e0,$00,$80,$07,$f0,$43,$24,$c0,$00,$57,$7f,$ff,$f2,$3e,$80
 $94d3 defb $38,$fc,$3f,$3f,$07,$ff,$f9,$f9,$ff,$03,$fe,$7f,$f0,$7f,$ff,$9f
 $94e3 defb $ff,$1c,$00,$08,$01,$ef,$e0,$00,$00,$00,$02,$55,$d5,$6c,$7f,$20
 $94f3 defb $38,$a4,$29,$2d,$00,$2d,$01,$69,$1d,$fe,$1a,$62,$5d,$02,$d0,$14
 $9503 defb $ff,$1c,$00,$00,$00,$f3,$0e,$f8,$00,$00,$00,$00,$4d,$aa,$fb,$b2
 $9513 defb $38,$3f,$fc,$3f,$ff,$3f,$01,$f9,$f8,$78,$7e,$7e,$07,$f3,$f0,$1f
 $9523 defb $ff,$1c,$99,$00,$ff,$fb,$fe,$a0,$00,$00,$00,$00,$01,$5a,$ba,$dd
 $9533 defb $38,$f0,$1e,$07,$9e,$03,$c0,$78,$79,$ef,$00,$79,$ef,$3d,$ef,$bd
 $9543 defb $e0,$1c,$00,$00,$00,$0b,$e0,$00,$00,$00,$00,$00,$00,$00,$00,$21
 $9553 defb $01,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $9563 defb $ff,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9573 defb $00,$00,$00,$00,$00,$00,$00,$fc,$f8,$e0,$0f,$07,$80,$fe,$70,$0e
 $9583 defb $00,$1c,$77,$00,$1e,$39,$fe,$f8,$38,$00,$00,$00,$00,$00,$00,$00
 $9593 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $95a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $95b3 defb $0f,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
 $95c3 defb $ff,$f0,$00,$80,$ff,$6f,$fc,$07,$00,$00,$15,$7f,$7f,$fd,$44,$10
 $95d3 defb $38,$fc,$3f,$3f,$00,$3f,$01,$f9,$ff,$87,$fe,$7f,$f8,$03,$f0,$1f
 $95e3 defb $80,$1c,$00,$04,$00,$df,$e0,$00,$00,$00,$00,$a5,$53,$52,$4d,$d6
 $95f3 defb $38,$84,$21,$21,$00,$21,$01,$09,$0a,$e1,$42,$42,$20,$82,$10,$10
 $9603 defb $80,$1c,$00,$00,$00,$df,$9e,$bc,$00,$00,$00,$00,$b7,$5d,$ff,$ec
 $9613 defb $38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9623 defb $00,$1c,$42,$03,$1f,$fb,$fe,$60,$00,$00,$00,$00,$00,$13,$6f,$7a
 $9633 defb $38,$f0,$1f,$f7,$9e,$ff,$c0,$78,$79,$ef,$f8,$7f,$ef,$3d,$e7,$3d
 $9643 defb $ff,$1c,$00,$00,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9653 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9663 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9673 defb $00,$00,$00,$00,$00,$00,$00,$e0,$ee,$fc,$7f,$3f,$80,$ef,$7e,$0e
 $9683 defb $00,$1c,$7f,$00,$fe,$3b,$8e,$ee,$38,$00,$00,$00,$00,$00,$00,$00
 $9693 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $96a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $96b3 defb $1e,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $96c3 defb $00,$78,$00,$40,$fb,$9e,$03,$f8,$00,$00,$55,$7f,$d7,$78,$3f,$40
 $96d3 defb $38,$fc,$3f,$3f,$00,$3f,$01,$f9,$ff,$87,$fe,$7f,$f8,$03,$f0,$1f
 $96e3 defb $80,$1c,$00,$04,$03,$3f,$f0,$00,$00,$00,$00,$01,$48,$48,$57,$39
 $96f3 defb $38,$84,$21,$21,$00,$21,$01,$09,$0a,$01,$42,$43,$e0,$82,$10,$10
 $9703 defb $80,$1c,$00,$00,$00,$ef,$ff,$47,$00,$00,$00,$05,$2a,$fb,$df,$fb
 $9713 defb $38,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9723 defb $00,$1c,$3c,$03,$e1,$f7,$fd,$c0,$00,$00,$00,$00,$00,$08,$9c,$fe
 $9733 defb $38,$f0,$1f,$f7,$9e,$ff,$80,$78,$79,$ef,$f8,$3f,$ef,$3d,$e7,$3d
 $9743 defb $ff,$1c,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9753 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9763 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $9773 defb $00,$00,$00,$00,$00,$00,$00,$e0,$e6,$fe,$fe,$7f,$00,$e7,$7f,$0e
 $9783 defb $00,$1c,$3e,$01,$fc,$3b,$8e,$e6,$38,$00,$00,$00,$00,$00,$00,$00
 $9793 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $97a3 defb $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 $97b3 defb $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46
 $97c3 defb $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46
 $97d3 defb $46,$46,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45
 $97e3 defb $45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$46,$46,$46
 $97f3 defb $46,$46,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45
 $9803 defb $45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$46,$46,$46
 $9813 defb $46,$46,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42
 $9823 defb $42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$46,$46,$46
 $9833 defb $46,$46,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42
 $9843 defb $42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$46,$46,$46
 $9853 defb $46,$46,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42
 $9863 defb $42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$42,$46,$46,$46
 $9873 defb $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46
 $9883 defb $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46
 $9893 defb $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46
 $98a3 defb $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46
 $98b3 defb $43,$00,$47,$43,$43,$00,$00,$47,$47,$00,$47,$00,$47,$00,$00,$47
 $98c3 defb $00,$00,$00,$00,$47,$47,$47,$47,$47,$47,$00,$43,$47,$47,$46,$47
 $98d3 defb $43,$00,$43,$43,$43,$43,$43,$47,$47,$00,$47,$43,$00,$00,$00,$00
 $98e3 defb $00,$47,$00,$00,$47,$47,$47,$47,$47,$47,$43,$43,$43,$43,$43,$47
 $98f3 defb $43,$43,$43,$43,$43,$43,$43,$43,$00,$43,$43,$43,$00,$43,$43,$00
 $9903 defb $47,$47,$00,$47,$47,$47,$47,$47,$47,$47,$47,$43,$43,$43,$43,$43
 $9913 defb $43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43
 $9923 defb $00,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$43,$43,$43,$43
 $9933 defb $42,$42,$42,$42,$43,$43,$43,$41,$41,$41,$45,$45,$44,$44,$46,$46
 $9943 defb $47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$00,$43,$43,$43
 $9953 defb $42,$42,$42,$42,$43,$43,$43,$41,$41,$41,$45,$45,$44,$44,$46,$46
 $9963 defb $47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$43,$43,$43
 $9973 defb $43,$43,$43,$43,$00,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43
 $9983 defb $43,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$46,$46,$43,$43
 $9993 defb $43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43,$43
 $99a3 defb $43,$43,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$46,$46,$42,$43
 $99b3 defb $47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47
 $99c3 defb $47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$46,$46,$46,$46,$42,$42
 $99d3 defb $47,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45
 $99e3 defb $45,$47,$00,$47,$47,$47,$47,$00,$00,$42,$46,$46,$46,$46,$42,$42
 $99f3 defb $47,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45,$45
 $9a03 defb $45,$47,$00,$47,$47,$47,$47,$47,$00,$00,$42,$42,$42,$42,$42,$42
 $9a13 defb $47,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44
 $9a23 defb $44,$47,$43,$47,$47,$47,$47,$47,$47,$00,$00,$00,$42,$42,$42,$42
 $9a33 defb $47,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44,$44
 $9a43 defb $44,$47,$00,$47,$47,$47,$47,$00,$00,$00,$00,$00,$00,$42,$42,$42
 $9a53 defb $47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47
 $9a63 defb $47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47,$47
 $9a73 defb $70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70
 $9a83 defb $70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70,$70
 $9a93 defb $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46
 $9aa3 defb $46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46,$46

; ZX Spectrum font sprites.
@label=system_font
b$9ab3 defb $00,$00,$00,$00,$00,$00,$00,$00
 $9abb defb $00,$10,$10,$10,$10,$00,$10,$00
 $9ac3 defb $00,$24,$24,$00,$00,$00,$00,$00
 $9acb defb $00,$24,$7e,$24,$24,$7e,$24,$00
 $9ad3 defb $00,$08,$3e,$28,$3e,$0a,$3e,$08
 $9adb defb $00,$62,$64,$08,$10,$26,$46,$00
 $9ae3 defb $00,$10,$28,$10,$2a,$44,$3a,$00
 $9aeb defb $00,$08,$10,$00,$00,$00,$00,$00
 $9af3 defb $00,$04,$08,$08,$08,$08,$04,$00
 $9afb defb $00,$20,$10,$10,$10,$10,$20,$00
 $9b03 defb $00,$00,$14,$08,$3e,$08,$14,$00
 $9b0b defb $00,$00,$08,$08,$3e,$08,$08,$00
 $9b13 defb $00,$00,$00,$00,$00,$08,$08,$10
 $9b1b defb $00,$00,$00,$00,$3e,$00,$00,$00
 $9b23 defb $00,$00,$00,$00,$00,$18,$18,$00
 $9b2b defb $00,$00,$02,$04,$08,$10,$20,$00
 $9b33 defb $00,$3c,$46,$4a,$52,$62,$3c,$00
 $9b3b defb $00,$18,$28,$08,$08,$08,$3e,$00
 $9b43 defb $00,$3c,$42,$02,$3c,$40,$7e,$00
 $9b4b defb $00,$3c,$42,$0c,$02,$42,$3c,$00
 $9b53 defb $00,$08,$18,$28,$48,$7e,$08,$00
 $9b5b defb $00,$7e,$40,$7c,$02,$42,$3c,$00
 $9b63 defb $00,$3c,$40,$7c,$42,$42,$3c,$00
 $9b6b defb $00,$7e,$02,$04,$08,$10,$10,$00
 $9b73 defb $00,$3c,$42,$3c,$42,$42,$3c,$00
 $9b7b defb $00,$3c,$42,$42,$3e,$02,$3c,$00
 $9b83 defb $00,$00,$00,$10,$00,$00,$10,$00
 $9b8b defb $00,$00,$10,$00,$00,$10,$10,$20
 $9b93 defb $00,$00,$04,$08,$10,$08,$04,$00
 $9b9b defb $00,$00,$00,$3e,$00,$3e,$00,$00
 $9ba3 defb $00,$00,$10,$08,$04,$08,$10,$00
 $9bab defb $00,$3c,$42,$04,$08,$00,$08,$00
 $9bb3 defb $00,$3c,$4a,$56,$5e,$40,$3c,$00
 $9bbb defb $00,$3c,$42,$42,$7e,$42,$42,$00
 $9bc3 defb $00,$7c,$42,$7c,$42,$42,$7c,$00
 $9bcb defb $00,$3c,$42,$40,$40,$42,$3c,$00
 $9bd3 defb $00,$78,$44,$42,$42,$44,$78,$00
 $9bdb defb $00,$7e,$40,$7c,$40,$40,$7e,$00
 $9be3 defb $00,$7e,$40,$7c,$40,$40,$40,$00
 $9beb defb $00,$3c,$42,$40,$4e,$42,$3c,$00
 $9bf3 defb $00,$42,$42,$7e,$42,$42,$42,$00
 $9bfb defb $00,$3e,$08,$08,$08,$08,$3e,$00
 $9c03 defb $00,$02,$02,$02,$42,$42,$3c,$00
 $9c0b defb $00,$44,$48,$70,$48,$44,$42,$00
 $9c13 defb $00,$40,$40,$40,$40,$40,$7e,$00
 $9c1b defb $00,$42,$66,$5a,$42,$42,$42,$00
 $9c23 defb $00,$42,$62,$52,$4a,$46,$42,$00
 $9c2b defb $00,$3c,$42,$42,$42,$42,$3c,$00
 $9c33 defb $00,$7c,$42,$42,$7c,$40,$40,$00
 $9c3b defb $00,$3c,$42,$42,$52,$4a,$3c,$00
 $9c43 defb $00,$7c,$42,$42,$7c,$44,$42,$00
 $9c4b defb $00,$3c,$40,$3c,$02,$42,$3c,$00
 $9c53 defb $00,$fe,$10,$10,$10,$10,$10,$00
 $9c5b defb $00,$42,$42,$42,$42,$42,$3c,$00
 $9c63 defb $00,$42,$42,$42,$42,$24,$18,$00
 $9c6b defb $00,$42,$42,$42,$42,$5a,$24,$00
 $9c73 defb $00,$42,$24,$18,$18,$24,$42,$00
 $9c7b defb $00,$82,$44,$28,$10,$10,$10,$00
 $9c83 defb $00,$7e,$04,$08,$10,$20,$7e,$00
 $9c8b defb $3c,$42,$99,$a1,$a1,$99,$42,$3c

; Unused.
i$9c93
